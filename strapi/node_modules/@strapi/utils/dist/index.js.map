{"version":3,"file":"index.js","sources":["../src/parse-type.ts","../src/env-helper.ts","../src/content-types.ts","../src/set-creator-fields.ts","../src/hooks.ts","../src/provider-factory.ts","../src/traverse-entity.ts","../src/import-default.ts","../src/machine-id.ts","../src/format-yup-error.ts","../src/errors.ts","../src/validators.ts","../src/operators.ts","../src/convert-query-params.ts","../src/async.ts","../src/sanitize/visitors/remove-password.ts","../src/sanitize/visitors/remove-private.ts","../src/relations.ts","../src/sanitize/visitors/remove-restricted-relations.ts","../src/sanitize/visitors/remove-morph-to-relations.ts","../src/sanitize/visitors/remove-dynamic-zones.ts","../src/sanitize/visitors/remove-disallowed-fields.ts","../src/sanitize/visitors/remove-restricted-fields.ts","../src/sanitize/visitors/expand-wildcard-populate.ts","../src/traverse/factory.ts","../src/traverse/query-filters.ts","../src/traverse/query-sort.ts","../src/traverse/query-populate.ts","../src/traverse/query-fields.ts","../src/sanitize/sanitizers.ts","../src/sanitize/index.ts","../src/validate/utils.ts","../src/validate/visitors/throw-password.ts","../src/validate/visitors/throw-private.ts","../src/validate/visitors/throw-restricted-relations.ts","../src/validate/visitors/throw-morph-to-relations.ts","../src/validate/visitors/throw-dynamic-zones.ts","../src/validate/visitors/throw-disallowed-fields.ts","../src/validate/visitors/throw-restricted-fields.ts","../src/validate/visitors/throw-unrecognized-fields.ts","../src/validate/validators.ts","../src/validate/index.ts","../src/pagination.ts","../src/package-manager.ts","../src/template.ts","../src/file.ts","../src/policy.ts","../src/primitives/strings.ts","../src/primitives/arrays.ts","../src/primitives/objects.ts","../src/primitives/dates.ts","../src/print-value.ts","../src/yup.ts","../src/zod.ts"],"sourcesContent":["import * as _ from 'lodash';\nimport * as dates from 'date-fns';\n\nconst timeRegex = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\n\nconst isDate = (v: unknown): v is Date => {\n  return dates.isDate(v);\n};\n\nconst parseTime = (value: unknown): string => {\n  if (isDate(value)) {\n    return dates.format(value, 'HH:mm:ss.SSS');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n  const result = value.match(timeRegex);\n\n  if (result === null) {\n    throw new Error('Invalid time format, expected HH:mm:ss.SSS');\n  }\n\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\n  const fractionPart = _.padEnd(fraction.slice(1), 3, '0');\n\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\n};\n\nconst parseDate = (value: unknown) => {\n  if (isDate(value)) {\n    return dates.format(value, 'yyyy-MM-dd');\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n\n    if (dates.isValid(date)) return dates.format(date, 'yyyy-MM-dd');\n\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected an ISO compatible date`);\n  }\n};\n\nconst parseDateTimeOrTimestamp = (value: unknown) => {\n  if (isDate(value)) {\n    return value;\n  }\n\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string, got a ${typeof value}`);\n  }\n\n  try {\n    const date = dates.parseISO(value);\n    if (dates.isValid(date)) return date;\n\n    const milliUnixDate = dates.parse(value, 'T', new Date());\n    if (dates.isValid(milliUnixDate)) return milliUnixDate;\n\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  } catch (error) {\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\n  }\n};\n\ntype TypeMap = {\n  boolean: boolean;\n  integer: number;\n  biginteger: number;\n  float: number;\n  decimal: number;\n  time: string;\n  date: string;\n  timestamp: Date;\n  datetime: Date;\n};\n\nexport interface ParseTypeOptions<T extends keyof TypeMap> {\n  type: T;\n  value: unknown;\n  forceCast?: boolean;\n}\n\nconst parseBoolean = (value: unknown, options: { forceCast?: boolean }): boolean => {\n  const { forceCast = false } = options;\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    if (['true', 't', '1', 1].includes(value)) {\n      return true;\n    }\n\n    if (['false', 'f', '0', 0].includes(value)) {\n      return false;\n    }\n  }\n\n  if (forceCast) {\n    return Boolean(value);\n  }\n\n  throw new Error('Invalid boolean input. Expected \"t\",\"1\",\"true\",\"false\",\"0\",\"f\"');\n};\n\n/**\n * Cast basic values based on attribute type\n */\nconst parseType = <Type extends keyof TypeMap>(options: ParseTypeOptions<Type>): TypeMap[Type] => {\n  const { type, value, forceCast } = options;\n\n  switch (type) {\n    case 'boolean':\n      return parseBoolean(value, { forceCast }) as TypeMap[Type];\n    case 'integer':\n    case 'biginteger':\n    case 'float':\n    case 'decimal': {\n      return _.toNumber(value) as TypeMap[Type];\n    }\n    case 'time': {\n      return parseTime(value) as TypeMap[Type];\n    }\n    case 'date': {\n      return parseDate(value) as TypeMap[Type];\n    }\n    case 'timestamp':\n    case 'datetime': {\n      return parseDateTimeOrTimestamp(value) as TypeMap[Type];\n    }\n    default:\n      return value as TypeMap[Type];\n  }\n};\n\nexport default parseType;\n","import _ from 'lodash';\n\nexport type Env = typeof envFn & typeof utils;\n\nfunction envFn<T>(key: string, defaultValue?: T): string | T | undefined {\n  return _.has(process.env, key) ? process.env[key] : defaultValue;\n}\n\nfunction getKey(key: string) {\n  return process.env[key] ?? '';\n}\n\nconst utils = {\n  int(key: string, defaultValue?: number): number | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return parseInt(getKey(key), 10);\n  },\n\n  float(key: string, defaultValue?: number): number | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return parseFloat(getKey(key));\n  },\n\n  bool(key: string, defaultValue?: boolean): boolean | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return getKey(key) === 'true';\n  },\n\n  json(key: string, defaultValue?: object) {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    try {\n      return JSON.parse(getKey(key));\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(`Invalid json environment variable ${key}: ${error.message}`);\n      }\n\n      throw error;\n    }\n  },\n\n  array(key: string, defaultValue?: string[]): string[] | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    let value = getKey(key);\n\n    if (value.startsWith('[') && value.endsWith(']')) {\n      value = value.substring(1, value.length - 1);\n    }\n\n    return value.split(',').map((v) => {\n      return _.trim(_.trim(v, ' '), '\"');\n    });\n  },\n\n  date(key: string, defaultValue?: Date): Date | undefined {\n    if (!_.has(process.env, key)) {\n      return defaultValue;\n    }\n\n    return new Date(getKey(key));\n  },\n\n  /**\n   * Gets a value from env that matches oneOf provided values\n   * @param {string} key\n   * @param {string[]} expectedValues\n   * @param {string|undefined} defaultValue\n   * @returns {string|undefined}\n   */\n  oneOf(key: string, expectedValues?: unknown[], defaultValue?: unknown) {\n    if (!expectedValues) {\n      throw new Error(`env.oneOf requires expectedValues`);\n    }\n\n    if (defaultValue && !expectedValues.includes(defaultValue)) {\n      throw new Error(`env.oneOf requires defaultValue to be included in expectedValues`);\n    }\n\n    const rawValue = env(key, defaultValue);\n    return expectedValues.includes(rawValue) ? rawValue : defaultValue;\n  },\n};\n\nconst env: Env = Object.assign(envFn, utils);\n\nexport default env;\n","import _ from 'lodash';\nimport { has, getOr, union } from 'lodash/fp';\nimport type {\n  Model,\n  Kind,\n  Attribute,\n  RelationalAttribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  WithRequired,\n} from './types';\n\nconst SINGLE_TYPE = 'singleType';\nconst COLLECTION_TYPE = 'collectionType';\n\nconst ID_ATTRIBUTE = 'id';\nconst DOC_ID_ATTRIBUTE = 'documentId';\n\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\n\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\n\nconst constants = {\n  ID_ATTRIBUTE,\n  DOC_ID_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  SINGLE_TYPE,\n  COLLECTION_TYPE,\n};\n\nconst getTimestamps = (model: Model) => {\n  const attributes: string[] = [];\n\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_AT_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_AT_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getCreatorFields = (model: Model) => {\n  const attributes: string[] = [];\n\n  if (has(CREATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_BY_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_BY_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_BY_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getNonWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  const nonWritableAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([\n    ID_ATTRIBUTE,\n    DOC_ID_ATTRIBUTE,\n    ...getTimestamps(model),\n    ...nonWritableAttributes,\n  ]);\n};\n\nconst getWritableAttributes = (model: Model) => {\n  if (!model) return [];\n\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\n};\n\nconst isWritableAttribute = (model: Model, attributeName: string) => {\n  return getWritableAttributes(model).includes(attributeName);\n};\n\nconst getNonVisibleAttributes = (model: Model) => {\n  const nonVisibleAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\n    [] as string[]\n  );\n\n  return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...getTimestamps(model), ...nonVisibleAttributes]);\n};\n\nconst getVisibleAttributes = (model: Model) => {\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\n};\n\nconst isVisibleAttribute = (model: Model, attributeName: string) => {\n  return getVisibleAttributes(model).includes(attributeName);\n};\n\nconst getOptions = (model: Model) =>\n  _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\n\nconst hasDraftAndPublish = (model: Model) =>\n  _.get(model, 'options.draftAndPublish', false) === true;\n\nconst isDraft = <T extends object>(data: T, model: Model) =>\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\n\nconst isSchema = (data: unknown): data is Model => {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'modelType' in data &&\n    typeof data.modelType === 'string' &&\n    ['component', 'contentType'].includes(data.modelType)\n  );\n};\n\nconst isComponentSchema = (data: unknown): data is Model & { modelType: 'component' } => {\n  return isSchema(data) && data.modelType === 'component';\n};\n\nconst isContentTypeSchema = (data: unknown): data is Model & { modelType: 'contentType' } => {\n  return isSchema(data) && data.modelType === 'contentType';\n};\n\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\nconst isKind = (kind: Kind) => (model: Model) => model.kind === kind;\n\nconst getStoredPrivateAttributes = (model: Model) =>\n  union(\n    (strapi?.config?.get('api.responses.privateAttributes', []) ?? []) as Array<string>,\n    getOr([], 'options.privateAttributes', model)\n  );\n\nconst getPrivateAttributes = (model: Model) => {\n  return _.union(\n    getStoredPrivateAttributes(model),\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\n  );\n};\n\nconst isPrivateAttribute = (model: Model, attributeName: string) => {\n  if (model?.attributes?.[attributeName]?.private === true) {\n    return true;\n  }\n  return getStoredPrivateAttributes(model).includes(attributeName);\n};\n\nconst isScalarAttribute = (attribute?: Attribute) => {\n  return attribute && !['media', 'component', 'relation', 'dynamiczone'].includes(attribute.type);\n};\n\nconst getDoesAttributeRequireValidation = (attribute: Attribute) => {\n  return (\n    attribute.required ||\n    attribute.unique ||\n    Object.prototype.hasOwnProperty.call(attribute, 'max') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'min') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'maxLength') ||\n    Object.prototype.hasOwnProperty.call(attribute, 'minLength')\n  );\n};\nconst isMediaAttribute = (attribute?: Attribute) => attribute?.type === 'media';\nconst isRelationalAttribute = (attribute?: Attribute): attribute is RelationalAttribute =>\n  attribute?.type === 'relation';\n\nconst HAS_RELATION_REORDERING = ['manyToMany', 'manyToOne', 'oneToMany'];\nconst hasRelationReordering = (attribute?: Attribute) =>\n  isRelationalAttribute(attribute) && HAS_RELATION_REORDERING.includes(attribute.relation);\n\nconst isComponentAttribute = (\n  attribute: Attribute\n): attribute is ComponentAttribute | DynamicZoneAttribute =>\n  ['component', 'dynamiczone'].includes(attribute?.type);\n\nconst isDynamicZoneAttribute = (attribute?: Attribute): attribute is DynamicZoneAttribute =>\n  !!attribute && attribute.type === 'dynamiczone';\nconst isMorphToRelationalAttribute = (attribute?: Attribute) => {\n  return (\n    !!attribute && isRelationalAttribute(attribute) && attribute.relation?.startsWith?.('morphTo')\n  );\n};\n\nconst getComponentAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isComponentAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getScalarAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isScalarAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\nconst getRelationalAttributes = (schema: Model) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isRelationalAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    [] as string[]\n  );\n};\n\n/**\n * Checks if an attribute is of type `type`\n * @param {object} attribute\n * @param {string} type\n */\nconst isTypedAttribute = (attribute: Attribute, type: string) => {\n  return _.has(attribute, 'type') && attribute.type === type;\n};\n\n/**\n *  Returns a route prefix for a contentType\n * @param {object} contentType\n * @returns {string}\n */\nconst getContentTypeRoutePrefix = (contentType: WithRequired<Model, 'info'>) => {\n  return isSingleType(contentType)\n    ? _.kebabCase(contentType.info.singularName)\n    : _.kebabCase(contentType.info.pluralName);\n};\n\nexport {\n  isSchema,\n  isContentTypeSchema,\n  isComponentSchema,\n  isScalarAttribute,\n  isMediaAttribute,\n  isRelationalAttribute,\n  hasRelationReordering,\n  isComponentAttribute,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  isPrivateAttribute,\n  constants,\n  getNonWritableAttributes,\n  getComponentAttributes,\n  getScalarAttributes,\n  getRelationalAttributes,\n  getWritableAttributes,\n  isWritableAttribute,\n  getNonVisibleAttributes,\n  getVisibleAttributes,\n  getTimestamps,\n  getCreatorFields,\n  isVisibleAttribute,\n  getOptions,\n  isDraft,\n  hasDraftAndPublish,\n  isSingleType,\n  isCollectionType,\n  isKind,\n  getContentTypeRoutePrefix,\n  getDoesAttributeRequireValidation,\n};\n","import { assign, assoc } from 'lodash/fp';\nimport * as contentTypes from './content-types';\n\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypes.constants;\n\nexport interface Options {\n  user: User;\n  isEdition?: boolean;\n}\n\ninterface User {\n  id: string | number;\n}\n\nconst setCreatorFields =\n  <TData extends object>({ user, isEdition = false }: Options) =>\n  <TDataInner extends object = TData>(data: TDataInner) => {\n    if (isEdition) {\n      return assoc(UPDATED_BY_ATTRIBUTE, user.id, data);\n    }\n\n    return assign(data, {\n      [CREATED_BY_ATTRIBUTE]: user.id,\n      [UPDATED_BY_ATTRIBUTE]: user.id,\n    });\n  };\n\nexport default setCreatorFields;\n","import { eq, remove, cloneDeep } from 'lodash/fp';\n\nexport type Handler = (...args: any[]) => any;\n\nexport interface Hook<T extends Handler = Handler> {\n  getHandlers(): Handler[];\n  register(handler: T): Hook<T>;\n  delete(handler: T): Hook<T>;\n  call(...args: any[]): void;\n}\n\nexport interface AsyncSeriesHook extends Hook {\n  call(...args: any[]): Promise<void>;\n}\nexport interface AsyncSeriesWaterfallHook extends Hook {\n  call(...args: any[]): Promise<any>;\n}\n\nexport interface AsyncParallelHook extends Hook {\n  call(...args: any[]): Promise<any[]>;\n}\n\nexport interface AsyncBailHook extends Hook {\n  call(...args: any[]): Promise<any>;\n}\n\n/**\n * Create a default Strapi hook\n */\nconst createHook = <T extends Handler = Handler>(): Hook<T> => {\n  type State = {\n    handlers: T[];\n  };\n\n  const state: State = {\n    handlers: [],\n  };\n\n  return {\n    getHandlers() {\n      return state.handlers;\n    },\n\n    register(handler: T) {\n      state.handlers.push(handler);\n\n      return this;\n    },\n\n    delete(handler: T) {\n      state.handlers = remove(eq(handler), state.handlers);\n\n      return this;\n    },\n\n    call() {\n      throw new Error('Method not implemented');\n    },\n  };\n};\n\n/**\n * Create an async series hook.\n * Upon execution, it will execute every handler in order with the same context\n */\nconst createAsyncSeriesHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    for (const handler of this.getHandlers()) {\n      await handler(context);\n    }\n  },\n});\n\n/**\n * Create an async series waterfall hook.\n * Upon execution, it will execute every handler in order and pass the return value of the last handler to the next one\n */\nconst createAsyncSeriesWaterfallHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(param: unknown) {\n    let res = param;\n\n    for (const handler of this.getHandlers()) {\n      res = await handler(res);\n    }\n\n    return res;\n  },\n});\n\n/**\n * Create an async parallel hook.\n * Upon execution, it will execute every registered handler in band.\n */\nconst createAsyncParallelHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    const promises = this.getHandlers().map((handler) => handler(cloneDeep(context)));\n\n    return Promise.all(promises);\n  },\n});\n\n/**\n * Create an async parallel hook.\n * Upon execution, it will execute every registered handler in serie and return the first result found.\n */\nconst createAsyncBailHook = <T extends Handler = Handler>() => ({\n  ...createHook<T>(),\n\n  async call(context: unknown) {\n    for (const handler of this.getHandlers()) {\n      const result = await handler(context);\n\n      if (result !== undefined) {\n        return result;\n      }\n    }\n  },\n});\n\nexport const internals = {\n  // Internal utils\n  createHook,\n};\n\nexport {\n  createAsyncSeriesHook,\n  createAsyncSeriesWaterfallHook,\n  createAsyncParallelHook,\n  createAsyncBailHook,\n};\n","import { cloneDeep } from 'lodash/fp';\nimport {\n  createAsyncSeriesHook,\n  createAsyncParallelHook,\n  AsyncSeriesHook,\n  AsyncParallelHook,\n} from './hooks';\n\nexport interface ProviderHooksMap {\n  willRegister: AsyncSeriesHook;\n  didRegister: AsyncParallelHook;\n  willDelete: AsyncParallelHook;\n  didDelete: AsyncParallelHook;\n}\n\n/**\n * Creates a new object containing various hooks used by the providers\n */\nconst createProviderHooksMap = (): ProviderHooksMap => ({\n  // Register events\n  willRegister: createAsyncSeriesHook(),\n  didRegister: createAsyncParallelHook(),\n  // Delete events\n  willDelete: createAsyncParallelHook(),\n  didDelete: createAsyncParallelHook(),\n});\n\nexport interface Options {\n  throwOnDuplicates?: boolean;\n}\n\ntype Item = Record<string, unknown>;\n\nexport interface Provider<T = unknown> {\n  hooks: ProviderHooksMap;\n  register(key: string, item: T): Promise<Provider>;\n  delete(key: string): Promise<Provider>;\n  get(key: string): T | undefined;\n  values(): T[];\n  keys(): string[];\n  has(key: string): boolean;\n  size(): number;\n  clear(): Promise<Provider<T>>;\n}\n\nexport type ProviderFactory<T> = (options?: Options) => Provider<T>;\n\n/**\n * A Provider factory\n */\nconst providerFactory = <T = Item>(options: Options = {}): Provider<T> => {\n  const { throwOnDuplicates = true } = options;\n\n  const state = {\n    hooks: createProviderHooksMap(),\n    registry: new Map<string, T>(),\n  };\n\n  return {\n    hooks: state.hooks,\n\n    async register(key: string, item: T) {\n      if (throwOnDuplicates && this.has(key)) {\n        throw new Error(`Duplicated item key: ${key}`);\n      }\n\n      await state.hooks.willRegister.call({ key, value: item });\n\n      state.registry.set(key, item);\n\n      await state.hooks.didRegister.call({ key, value: cloneDeep(item) });\n\n      return this;\n    },\n\n    async delete(key: string) {\n      if (this.has(key)) {\n        const item = this.get(key);\n\n        await state.hooks.willDelete.call({ key, value: cloneDeep(item) });\n\n        state.registry.delete(key);\n\n        await state.hooks.didDelete.call({ key, value: cloneDeep(item) });\n      }\n\n      return this;\n    },\n\n    get(key: string) {\n      return state.registry.get(key);\n    },\n\n    values() {\n      return Array.from(state.registry.values());\n    },\n\n    keys() {\n      return Array.from(state.registry.keys());\n    },\n\n    has(key: string) {\n      return state.registry.has(key);\n    },\n\n    size() {\n      return state.registry.size;\n    },\n\n    async clear() {\n      const keys = this.keys();\n\n      for (const key of keys) {\n        await this.delete(key);\n      }\n\n      return this;\n    },\n  };\n};\n\nexport default providerFactory;\n","import { clone, isObject, isArray, isNil, curry } from 'lodash/fp';\n\nimport type { Attribute, AnyAttribute, Model, Data } from './types';\nimport { isRelationalAttribute, isMediaAttribute } from './content-types';\n\nexport type VisitorUtils = ReturnType<typeof createVisitorUtils>;\n\nexport interface VisitorOptions {\n  data: Record<string, unknown>;\n  schema: Model;\n  key: string;\n  value: Data[keyof Data];\n  attribute?: AnyAttribute;\n  path: Path;\n  getModel(uid: string): Model;\n  parent?: Parent;\n}\n\nexport type Visitor = (visitorOptions: VisitorOptions, visitorUtils: VisitorUtils) => void;\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n}\n\nexport interface TraverseOptions {\n  schema: Model;\n  path?: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport interface Parent {\n  attribute?: Attribute;\n  key: string | null;\n  path: Path;\n  schema: Model;\n}\n\nconst traverseEntity = async (visitor: Visitor, options: TraverseOptions, entity: Data) => {\n  const { path = { raw: null, attribute: null }, schema, getModel } = options;\n\n  let parent = options.parent;\n\n  const traverseMorphRelationTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchema = getModel(entry.__type!);\n\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const traverseRelationTarget =\n    (schema: Model) => async (visitor: Visitor, path: Path, entry: Data) => {\n      const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\n\n      return traverseEntity(visitor, traverseOptions, entry);\n    };\n\n  const traverseMediaTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const traverseComponent = async (visitor: Visitor, path: Path, schema: Model, entry: Data) => {\n    const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const visitDynamicZoneEntry = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchema = getModel(entry.__component!);\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  // End recursion\n  if (!isObject(entity) || isNil(schema)) {\n    return entity;\n  }\n\n  // Don't mutate the original entity object\n  // only clone at 1st level as the next level will get clone when traversed\n  const copy = clone(entity);\n  const visitorUtils = createVisitorUtils({ data: copy });\n\n  const keys = Object.keys(copy);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    // Retrieve the attribute definition associated to the key from the schema\n    const attribute = schema.attributes[key] as AnyAttribute | undefined;\n\n    const newPath = { ...path };\n\n    newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n\n    if (!isNil(attribute)) {\n      newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n    }\n\n    // Visit the current attribute\n    const visitorOptions: VisitorOptions = {\n      data: copy,\n      schema,\n      key,\n      value: copy[key],\n      attribute,\n      path: newPath,\n      getModel,\n      parent,\n    };\n\n    await visitor(visitorOptions, visitorUtils);\n\n    // Extract the value for the current key (after calling the visitor)\n    const value = copy[key];\n\n    // Ignore Nil values or attributes\n    if (isNil(value) || isNil(attribute)) {\n      continue;\n    }\n\n    // The current attribute becomes the parent once visited\n    parent = { schema, key, attribute, path: newPath };\n\n    if (isRelationalAttribute(attribute)) {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      const method = isMorphRelation\n        ? traverseMorphRelationTarget\n        : traverseRelationTarget(getModel(attribute.target!));\n\n      if (isArray(value)) {\n        const res = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await method(visitor, newPath, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await method(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (isMediaAttribute(attribute)) {\n      // need to update copy\n      if (isArray(value)) {\n        const res = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await traverseMediaTarget(visitor, newPath, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await traverseMediaTarget(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const targetSchema = getModel(attribute.component);\n\n      if (isArray(value)) {\n        const res: Data[] = new Array(value.length);\n        for (let i = 0; i < value.length; i += 1) {\n          res[i] = await traverseComponent(visitor, newPath, targetSchema, value[i]);\n        }\n        copy[key] = res;\n      } else {\n        copy[key] = await traverseComponent(visitor, newPath, targetSchema, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone' && isArray(value)) {\n      const res = new Array(value.length);\n      for (let i = 0; i < value.length; i += 1) {\n        res[i] = await visitDynamicZoneEntry(visitor, newPath, value[i]);\n      }\n      copy[key] = res;\n\n      continue;\n    }\n  }\n\n  return copy;\n};\n\nconst createVisitorUtils = ({ data }: { data: Data }) => ({\n  remove(key: string) {\n    delete data[key];\n  },\n\n  set(key: string, value: Data) {\n    data[key] = value;\n  },\n});\n\nexport default curry(traverseEntity);\n","/* eslint-disable @typescript-eslint/no-var-requires */\n\nexport default function importDefault(modName: string) {\n  const mod = require(modName);\n  return mod && mod.__esModule ? mod.default : mod;\n}\n","import { randomUUID } from 'crypto';\nimport { machineIdSync } from 'node-machine-id';\n\nexport default () => {\n  try {\n    const deviceId = machineIdSync();\n    return deviceId;\n  } catch (error) {\n    const deviceId = randomUUID();\n    return deviceId;\n  }\n};\n","import { isEmpty, toPath } from 'lodash/fp';\nimport { ValidationError } from 'yup';\n\nconst formatYupInnerError = (yupError: ValidationError) => ({\n  path: toPath(yupError.path),\n  message: yupError.message,\n  name: yupError.name,\n});\n\nconst formatYupErrors = (yupError: ValidationError) => ({\n  errors: isEmpty(yupError.inner)\n    ? [formatYupInnerError(yupError)]\n    : yupError.inner.map(formatYupInnerError),\n  message: yupError.message,\n});\n\nexport { formatYupErrors };\n","/* eslint-disable max-classes-per-file */\n\nimport yup from 'yup';\nimport { HttpError } from 'http-errors';\nimport { formatYupErrors } from './format-yup-error';\n\n/* ApplicationError */\nclass ApplicationError<\n  TName extends string = 'ApplicationError',\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends Error {\n  name: TName;\n\n  details: TDetails;\n\n  message: TMessage;\n\n  constructor(\n    message = 'An application error occured' as TMessage,\n    details: TDetails = {} as TDetails\n  ) {\n    super();\n    this.name = 'ApplicationError' as TName;\n    this.message = message;\n    this.details = details;\n  }\n}\n\nclass ValidationError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'ValidationError', TMessage, TDetails> {\n  constructor(message: TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'ValidationError';\n  }\n}\n\ninterface YupFormattedError {\n  path: string[];\n  message: string;\n  name: string;\n}\n\nclass YupValidationError<TMessage extends string = string> extends ValidationError<\n  TMessage,\n  { errors: YupFormattedError[] }\n> {\n  constructor(yupError: yup.ValidationError, message?: TMessage) {\n    super('Validation' as TMessage);\n    const { errors, message: yupMessage } = formatYupErrors(yupError);\n    this.message = message || (yupMessage as TMessage);\n    this.details = { errors };\n  }\n}\n\nclass PaginationError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'PaginationError', TMessage, TDetails> {\n  constructor(message = 'Invalid pagination' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PaginationError';\n    this.message = message;\n  }\n}\n\nclass NotFoundError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\n  'NotFoundError',\n  TMessage,\n  TDetails\n> {\n  constructor(message = 'Entity not found' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'NotFoundError';\n    this.message = message;\n  }\n}\n\nclass ForbiddenError<\n  TName extends string = 'ForbiddenError',\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<TName, TMessage, TDetails> {\n  constructor(message = 'Forbidden access' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'ForbiddenError' as TName;\n    this.message = message;\n  }\n}\n\nclass UnauthorizedError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'UnauthorizedError', TMessage, TDetails> {\n  constructor(message = 'Unauthorized' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'UnauthorizedError';\n    this.message = message;\n  }\n}\n\nclass RateLimitError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\n  'RateLimitError',\n  TMessage,\n  TDetails\n> {\n  constructor(\n    message = 'Too many requests, please try again later.' as TMessage,\n    details?: TDetails\n  ) {\n    super(message, details);\n    this.name = 'RateLimitError';\n    this.message = message;\n    this.details = details || ({} as TDetails);\n  }\n}\n\nclass PayloadTooLargeError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'PayloadTooLargeError', TMessage, TDetails> {\n  constructor(message = 'Entity too large' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PayloadTooLargeError';\n    this.message = message;\n  }\n}\n\nclass PolicyError<TMessage extends string = string, TDetails = unknown> extends ForbiddenError<\n  'PolicyError',\n  TMessage,\n  TDetails\n> {\n  constructor(message = 'Policy Failed' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'PolicyError';\n    this.message = message;\n    this.details = details || ({} as TDetails);\n  }\n}\n\nclass NotImplementedError<\n  TMessage extends string = string,\n  TDetails = unknown,\n> extends ApplicationError<'NotImplementedError', TMessage, TDetails> {\n  constructor(message = 'This feature is not implemented yet' as TMessage, details?: TDetails) {\n    super(message, details);\n    this.name = 'NotImplementedError';\n    this.message = message;\n  }\n}\n\nexport {\n  HttpError,\n  ApplicationError,\n  ValidationError,\n  YupValidationError,\n  PaginationError,\n  NotFoundError,\n  ForbiddenError,\n  UnauthorizedError,\n  RateLimitError,\n  PayloadTooLargeError,\n  PolicyError,\n  NotImplementedError,\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable no-template-curly-in-string */\nimport * as yup from 'yup';\nimport { defaults } from 'lodash/fp';\nimport { YupValidationError } from './errors';\n\nconst handleYupError = (error: yup.ValidationError, errorMessage?: string) => {\n  throw new YupValidationError(error, errorMessage);\n};\n\nconst defaultValidationParam = { strict: true, abortEarly: false };\n\nconst validateYupSchema =\n  <TSchema extends yup.AnySchema>(schema: TSchema, options = {}) =>\n  async (body: unknown, errorMessage?: string): Promise<yup.InferType<TSchema>> => {\n    try {\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\n      const result = await schema.validate(body, optionsWithDefaults);\n      return result;\n    } catch (e) {\n      if (e instanceof yup.ValidationError) {\n        handleYupError(e, errorMessage);\n      }\n\n      throw e;\n    }\n  };\n\nconst validateYupSchemaSync =\n  <TSchema extends yup.AnySchema>(schema: yup.AnySchema, options = {}) =>\n  (body: unknown, errorMessage?: string): yup.InferType<TSchema> => {\n    try {\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\n      return schema.validateSync(body, optionsWithDefaults);\n    } catch (e) {\n      if (e instanceof yup.ValidationError) {\n        handleYupError(e, errorMessage);\n      }\n\n      throw e;\n    }\n  };\n\nexport { handleYupError, validateYupSchema, validateYupSchemaSync };\n","const GROUP_OPERATORS = ['$and', '$or'];\n\nconst WHERE_OPERATORS = [\n  '$not',\n  '$in',\n  '$notIn',\n  '$eq',\n  '$eqi',\n  '$ne',\n  '$nei',\n  '$gt',\n  '$gte',\n  '$lt',\n  '$lte',\n  '$null',\n  '$notNull',\n  '$between',\n  '$startsWith',\n  '$endsWith',\n  '$startsWithi',\n  '$endsWithi',\n  '$contains',\n  '$notContains',\n  '$containsi',\n  '$notContainsi',\n  // Experimental, only for internal use\n  '$jsonSupersetOf',\n];\n\nconst CAST_OPERATORS = [\n  '$not',\n  '$in',\n  '$notIn',\n  '$eq',\n  '$ne',\n  '$gt',\n  '$gte',\n  '$lt',\n  '$lte',\n  '$between',\n];\n\nconst ARRAY_OPERATORS = ['$in', '$notIn', '$between'];\n\nconst OPERATORS = {\n  where: WHERE_OPERATORS,\n  cast: CAST_OPERATORS,\n  group: GROUP_OPERATORS,\n  array: ARRAY_OPERATORS,\n};\n\n// for performance, cache all operators in lowercase\nconst OPERATORS_LOWERCASE = Object.fromEntries(\n  Object.entries(OPERATORS).map(([key, values]) => [\n    key,\n    values.map((value) => value.toLowerCase()),\n  ])\n);\n\nconst isObjKey = <T extends object>(key: string | symbol | number, obj: T): key is keyof T => {\n  return key in obj;\n};\n\nexport const isOperatorOfType = (type: string, key: string, ignoreCase = false) => {\n  if (ignoreCase) {\n    return OPERATORS_LOWERCASE[type]?.includes(key.toLowerCase()) ?? false;\n  }\n\n  if (isObjKey(type, OPERATORS)) {\n    return OPERATORS[type]?.includes(key) ?? false;\n  }\n\n  return false;\n};\n\nexport const isOperator = (key: string, ignoreCase = false) => {\n  return Object.keys(OPERATORS).some((type) => isOperatorOfType(type, key, ignoreCase));\n};\n","/* eslint-disable max-classes-per-file */\n\n/**\n * Converts the standard Strapi REST query params to a more usable format for querying\n * You can read more here: https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#filters\n */\n\nimport _ from 'lodash';\nimport {\n  cloneDeep,\n  get,\n  isArray,\n  isEmpty,\n  isInteger,\n  isNil,\n  isObject,\n  isString,\n  toNumber,\n} from 'lodash/fp';\nimport {\n  constants,\n  hasDraftAndPublish,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n} from './content-types';\nimport { PaginationError } from './errors';\nimport { isOperator } from './operators';\n\nimport parseType from './parse-type';\nimport { Model } from './types';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE } = constants;\n\ntype SortOrder = 'asc' | 'desc';\n\nexport interface SortMap {\n  [key: string]: SortOrder | SortMap;\n}\n\nexport interface SortParamsObject {\n  [key: string]: SortOrder | SortParamsObject;\n}\n\ntype SortParams = string | string[] | SortParamsObject | SortParamsObject[];\ntype FieldsParams = string | string[];\n\ntype FiltersParams = unknown;\n\nexport interface PopulateAttributesParams {\n  [key: string]: boolean | PopulateObjectParams;\n}\n\nexport interface PopulateObjectParams {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: string | string[] | PopulateAttributesParams;\n  on?: PopulateAttributesParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n}\n\ntype PopulateParams = string | string[] | PopulateAttributesParams;\n\nexport interface Params {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: PopulateParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n  status?: 'draft' | 'published';\n}\n\ntype FiltersQuery = (options: { meta: Model }) => WhereQuery | undefined;\ntype OrderByQuery = SortMap | SortMap[];\ntype SelectQuery = string | string[];\n\nexport interface WhereQuery {\n  [key: string]: any;\n}\n\ntype PopulateQuery =\n  | boolean\n  | string[]\n  | {\n      [key: string]: PopulateQuery;\n    };\n\nexport interface Query {\n  orderBy?: OrderByQuery;\n  select?: SelectQuery;\n  where?: WhereQuery;\n  // NOTE: those are internal DB filters do not modify\n  filters?: FiltersQuery;\n  populate?: PopulateQuery;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number;\n  offset?: number;\n  page?: number;\n  pageSize?: number;\n}\n\nclass InvalidOrderError extends Error {\n  constructor() {\n    super();\n    this.message = 'Invalid order. order can only be one of asc|desc|ASC|DESC';\n  }\n}\n\nclass InvalidSortError extends Error {\n  constructor() {\n    super();\n    this.message =\n      'Invalid sort parameter. Expected a string, an array of strings, a sort object or an array of sort objects';\n  }\n}\n\nfunction validateOrder(order: string): asserts order is SortOrder {\n  if (!isString(order) || !['asc', 'desc'].includes(order.toLocaleLowerCase())) {\n    throw new InvalidOrderError();\n  }\n}\n\nconst convertCountQueryParams = (countQuery: unknown): boolean => {\n  return parseType({ type: 'boolean', value: countQuery });\n};\n\nconst convertOrderingQueryParams = (ordering: unknown) => {\n  return ordering;\n};\n\nconst isPlainObject = (value: unknown): value is Record<string, unknown> => _.isPlainObject(value);\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\ninterface TransformerOptions {\n  getModel: (uid: string) => Model | undefined;\n}\n\nconst createTransformer = ({ getModel }: TransformerOptions) => {\n  /**\n   * Sort query parser\n   */\n  const convertSortQueryParams = (sortQuery: SortParams): OrderByQuery => {\n    if (typeof sortQuery === 'string') {\n      return convertStringSortQueryParam(sortQuery);\n    }\n\n    if (isStringArray(sortQuery)) {\n      return sortQuery.flatMap((sortValue: string) => convertStringSortQueryParam(sortValue));\n    }\n\n    if (Array.isArray(sortQuery)) {\n      return sortQuery.map((sortValue) => convertNestedSortQueryParam(sortValue));\n    }\n\n    if (isPlainObject(sortQuery)) {\n      return convertNestedSortQueryParam(sortQuery);\n    }\n\n    throw new InvalidSortError();\n  };\n\n  const convertStringSortQueryParam = (sortQuery: string): SortMap[] => {\n    return sortQuery.split(',').map((value) => convertSingleSortQueryParam(value));\n  };\n\n  const convertSingleSortQueryParam = (sortQuery: string): SortMap => {\n    if (!sortQuery) {\n      return {};\n    }\n\n    if (!isString(sortQuery)) {\n      throw new Error('Invalid sort query');\n    }\n\n    // split field and order param with default order to ascending\n    const [field, order = 'asc'] = sortQuery.split(':');\n\n    if (field.length === 0) {\n      throw new Error('Field cannot be empty');\n    }\n\n    validateOrder(order);\n\n    // TODO: field should be a valid path on an object model\n\n    return _.set({}, field, order);\n  };\n\n  const convertNestedSortQueryParam = (sortQuery: SortParamsObject): SortMap => {\n    const transformedSort: SortMap = {};\n    for (const field of Object.keys(sortQuery)) {\n      const order = sortQuery[field];\n\n      // this is a deep sort\n      if (isPlainObject(order)) {\n        transformedSort[field] = convertNestedSortQueryParam(order);\n      } else if (typeof order === 'string') {\n        validateOrder(order);\n        transformedSort[field] = order;\n      } else {\n        throw Error(`Invalid sort type expected object or string got ${typeof order}`);\n      }\n    }\n\n    return transformedSort;\n  };\n\n  /**\n   * Start query parser\n   */\n  const convertStartQueryParams = (startQuery: unknown): number => {\n    const startAsANumber = toNumber(startQuery);\n\n    if (!_.isInteger(startAsANumber) || startAsANumber < 0) {\n      throw new Error(`convertStartQueryParams expected a positive integer got ${startAsANumber}`);\n    }\n\n    return startAsANumber;\n  };\n\n  /**\n   * Limit query parser\n   */\n  const convertLimitQueryParams = (limitQuery: unknown): number | undefined => {\n    const limitAsANumber = toNumber(limitQuery);\n\n    if (!_.isInteger(limitAsANumber) || (limitAsANumber !== -1 && limitAsANumber < 0)) {\n      throw new Error(`convertLimitQueryParams expected a positive integer got ${limitAsANumber}`);\n    }\n\n    if (limitAsANumber === -1) {\n      return undefined;\n    }\n\n    return limitAsANumber;\n  };\n\n  const convertPageQueryParams = (page: unknown): number => {\n    const pageVal = toNumber(page);\n\n    if (!isInteger(pageVal) || pageVal <= 0) {\n      throw new PaginationError(\n        `Invalid 'page' parameter. Expected an integer > 0, received: ${page}`\n      );\n    }\n\n    return pageVal;\n  };\n\n  const convertPageSizeQueryParams = (pageSize: unknown, page: unknown): number => {\n    const pageSizeVal = toNumber(pageSize);\n\n    if (!isInteger(pageSizeVal) || pageSizeVal <= 0) {\n      throw new PaginationError(\n        `Invalid 'pageSize' parameter. Expected an integer > 0, received: ${page}`\n      );\n    }\n\n    return pageSizeVal;\n  };\n\n  const validatePaginationParams = (\n    page: unknown,\n    pageSize: unknown,\n    start: unknown,\n    limit: unknown\n  ) => {\n    const isPagePagination = !isNil(page) || !isNil(pageSize);\n    const isOffsetPagination = !isNil(start) || !isNil(limit);\n\n    if (isPagePagination && isOffsetPagination) {\n      throw new PaginationError(\n        'Invalid pagination attributes. You cannot use page and offset pagination in the same query'\n      );\n    }\n  };\n\n  class InvalidPopulateError extends Error {\n    constructor() {\n      super();\n      this.message =\n        'Invalid populate parameter. Expected a string, an array of strings, a populate object';\n    }\n  }\n\n  // NOTE: we could support foo.* or foo.bar.* etc later on\n  const convertPopulateQueryParams = (\n    populate: PopulateParams,\n    schema?: Model,\n    depth = 0\n  ): PopulateQuery => {\n    if (depth === 0 && populate === '*') {\n      return true;\n    }\n\n    if (typeof populate === 'string') {\n      return populate.split(',').map((value) => _.trim(value));\n    }\n\n    if (Array.isArray(populate)) {\n      // map convert\n      return _.uniq(\n        populate.flatMap((value) => {\n          if (typeof value !== 'string') {\n            throw new InvalidPopulateError();\n          }\n\n          return value.split(',').map((value) => _.trim(value));\n        })\n      );\n    }\n\n    if (_.isPlainObject(populate)) {\n      return convertPopulateObject(populate, schema);\n    }\n\n    throw new InvalidPopulateError();\n  };\n\n  const hasPopulateFragmentDefined = (\n    populate: PopulateObjectParams\n  ): populate is PopulateObjectParams & Required<Pick<PopulateObjectParams, 'on'>> => {\n    return typeof populate === 'object' && 'on' in populate && !isNil(populate.on);\n  };\n\n  const hasCountDefined = (\n    populate: PopulateObjectParams\n  ): populate is PopulateObjectParams & { count: boolean } => {\n    return (\n      typeof populate === 'object' && 'count' in populate && typeof populate.count === 'boolean'\n    );\n  };\n\n  const convertPopulateObject = (populate: PopulateAttributesParams, schema?: Model) => {\n    if (!schema) {\n      return {};\n    }\n\n    const { attributes } = schema;\n    return Object.entries(populate).reduce((acc, [key, subPopulate]) => {\n      // Try converting strings to regular booleans if possible\n      if (_.isString(subPopulate)) {\n        try {\n          const subPopulateAsBoolean = parseType({ type: 'boolean', value: subPopulate });\n          // Only true is accepted as a boolean populate value\n          return subPopulateAsBoolean ? { ...acc, [key]: true } : acc;\n        } catch {\n          // ignore\n        }\n      }\n\n      if (_.isBoolean(subPopulate)) {\n        // Only true is accepted as a boolean populate value\n        return subPopulate === true ? { ...acc, [key]: true } : acc;\n      }\n\n      const attribute = attributes[key];\n\n      if (!attribute) {\n        return acc;\n      }\n\n      // Allow adding an 'on' strategy to populate queries for morphTo relations and dynamic zones\n      const isMorphLikeRelationalAttribute =\n        isDynamicZoneAttribute(attribute) || isMorphToRelationalAttribute(attribute);\n\n      if (isMorphLikeRelationalAttribute) {\n        const hasInvalidProperties = Object.keys(subPopulate).some(\n          (key) => !['populate', 'on', 'count'].includes(key)\n        );\n\n        if (hasInvalidProperties) {\n          throw new Error(\n            `Invalid nested populate for ${schema.info?.singularName}.${key} (${schema.uid}). Expected a fragment (\"on\") or \"count\" but found ${JSON.stringify(subPopulate)}`\n          );\n        }\n\n        /**\n         * Validate nested population queries in the context of a polymorphic attribute (dynamic zone, morph relation).\n         *\n         * If 'populate' exists in subPopulate, its value should be constrained to a wildcard ('*').\n         */\n        if ('populate' in subPopulate && subPopulate.populate !== '*') {\n          throw new Error(\n            `Invalid nested population query detected. When using 'populate' within polymorphic structures, ` +\n              `its value must be '*' to indicate all second level links. Specific field targeting is not supported here. ` +\n              `Consider using the fragment API for more granular population control.`\n          );\n        }\n\n        // TODO: Remove the possibility to have multiple properties at the same time (on/count/populate)\n        const newSubPopulate = {};\n\n        // case: { populate: '*' }\n        if ('populate' in subPopulate) {\n          Object.assign(newSubPopulate, { populate: true });\n        }\n\n        // case: { on: { <clauses> } }\n        if (hasPopulateFragmentDefined(subPopulate)) {\n          // If the fragment API is used, it applies the transformation to every\n          // sub-populate, then assign the result to the new sub-populate\n          Object.assign(newSubPopulate, {\n            on: Object.entries(subPopulate.on).reduce(\n              (acc, [type, typeSubPopulate]) => ({\n                ...acc,\n                [type]: convertNestedPopulate(typeSubPopulate, getModel(type)),\n              }),\n              {}\n            ),\n          });\n        }\n\n        // case: { count: true | false }\n        if (hasCountDefined(subPopulate)) {\n          Object.assign(newSubPopulate, { count: subPopulate.count });\n        }\n\n        return { ...acc, [key]: newSubPopulate };\n      }\n\n      // Edge case when trying to use the fragment ('on') on a non-morph like attribute\n      if (!isMorphLikeRelationalAttribute && hasPopulateFragmentDefined(subPopulate)) {\n        throw new Error(`Using fragments is not permitted to populate \"${key}\" in \"${schema.uid}\"`);\n      }\n\n      // NOTE: Retrieve the target schema UID.\n      // Only handles basic relations, medias and component since it's not possible\n      // to populate with options for a dynamic zone or a polymorphic relation\n      let targetSchemaUID;\n\n      if (attribute.type === 'relation') {\n        targetSchemaUID = attribute.target;\n      } else if (attribute.type === 'component') {\n        targetSchemaUID = attribute.component;\n      } else if (attribute.type === 'media') {\n        targetSchemaUID = 'plugin::upload.file';\n      } else {\n        return acc;\n      }\n\n      const targetSchema = getModel(targetSchemaUID!);\n\n      // ignore the sub-populate for the current key if there is no schema associated\n      if (!targetSchema) {\n        return acc;\n      }\n\n      const populateObject = convertNestedPopulate(subPopulate, targetSchema);\n\n      if (!populateObject) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [key]: populateObject,\n      };\n    }, {});\n  };\n\n  const convertNestedPopulate = (subPopulate: boolean | PopulateObjectParams, schema?: Model) => {\n    if (_.isString(subPopulate)) {\n      return parseType({ type: 'boolean', value: subPopulate, forceCast: true });\n    }\n\n    if (_.isBoolean(subPopulate)) {\n      return subPopulate;\n    }\n\n    if (!isPlainObject(subPopulate)) {\n      throw new Error(`Invalid nested populate. Expected '*' or an object`);\n    }\n\n    const { sort, filters, fields, populate, count, ordering, page, pageSize, start, limit } =\n      subPopulate as PopulateObjectParams;\n\n    const query: Query = {};\n\n    if (sort) {\n      query.orderBy = convertSortQueryParams(sort);\n    }\n\n    if (filters) {\n      query.where = convertFiltersQueryParams(filters, schema);\n    }\n\n    if (fields) {\n      query.select = convertFieldsQueryParams(fields);\n    }\n\n    if (populate) {\n      query.populate = convertPopulateQueryParams(populate, schema);\n    }\n\n    if (count) {\n      query.count = convertCountQueryParams(count);\n    }\n\n    if (ordering) {\n      query.ordering = convertOrderingQueryParams(ordering);\n    }\n\n    validatePaginationParams(page, pageSize, start, limit);\n\n    if (!isNil(page)) {\n      query.page = convertPageQueryParams(page);\n    }\n\n    if (!isNil(pageSize)) {\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\n    }\n\n    if (!isNil(start)) {\n      query.offset = convertStartQueryParams(start);\n    }\n\n    if (!isNil(limit)) {\n      query.limit = convertLimitQueryParams(limit);\n    }\n\n    return query;\n  };\n\n  // TODO: ensure field is valid in content types (will probably have to check strapi.contentTypes since it can be a string.path)\n  const convertFieldsQueryParams = (fields: FieldsParams, depth = 0): SelectQuery | undefined => {\n    if (depth === 0 && fields === '*') {\n      return undefined;\n    }\n\n    if (typeof fields === 'string') {\n      const fieldsValues = fields.split(',').map((value) => _.trim(value));\n      return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\n    }\n\n    if (isStringArray(fields)) {\n      // map convert\n      const fieldsValues = fields\n        .flatMap((value) => convertFieldsQueryParams(value, depth + 1))\n        .filter((v) => !isNil(v)) as string[];\n\n      return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\n    }\n\n    throw new Error('Invalid fields parameter. Expected a string or an array of strings');\n  };\n\n  const isValidSchemaAttribute = (key: string, schema?: Model) => {\n    if ([DOC_ID_ATTRIBUTE, ID_ATTRIBUTE].includes(key)) {\n      return true;\n    }\n\n    if (!schema) {\n      return false;\n    }\n\n    return Object.keys(schema.attributes).includes(key);\n  };\n\n  const convertFiltersQueryParams = (filters: FiltersParams, schema?: Model): WhereQuery => {\n    // Filters need to be either an array or an object\n    // Here we're only checking for 'object' type since typeof [] => object and typeof {} => object\n    if (!isObject(filters)) {\n      throw new Error('The filters parameter must be an object or an array');\n    }\n\n    // Don't mutate the original object\n    const filtersCopy = cloneDeep(filters);\n\n    return convertAndSanitizeFilters(filtersCopy, schema);\n  };\n\n  const convertAndSanitizeFilters = (filters: FiltersParams, schema?: Model): WhereQuery => {\n    if (Array.isArray(filters)) {\n      return (\n        filters\n          // Sanitize each filter\n          .map((filter) => convertAndSanitizeFilters(filter, schema))\n          // Filter out empty filters\n          .filter((filter) => !isPlainObject(filter) || !isEmpty(filter))\n      );\n    }\n\n    if (!isPlainObject(filters)) {\n      return filters as WhereQuery;\n    }\n\n    const removeOperator = (operator: string) => delete filters[operator];\n\n    // Here, `key` can either be an operator or an attribute name\n    for (const [key, value] of Object.entries(filters)) {\n      const attribute = get(key, schema?.attributes);\n      const validKey = isOperator(key) || isValidSchemaAttribute(key, schema);\n\n      if (!validKey) {\n        removeOperator(key);\n      }\n      // Handle attributes\n      else if (attribute) {\n        // Relations\n        if (attribute.type === 'relation') {\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.target!));\n        }\n\n        // Components\n        else if (attribute.type === 'component') {\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.component));\n        }\n\n        // Media\n        else if (attribute.type === 'media') {\n          filters[key] = convertAndSanitizeFilters(value, getModel('plugin::upload.file'));\n        }\n\n        // Dynamic Zones\n        else if (attribute.type === 'dynamiczone') {\n          removeOperator(key);\n        }\n\n        // Password attributes\n        else if (attribute.type === 'password') {\n          // Always remove password attributes from filters object\n          removeOperator(key);\n        }\n\n        // Scalar attributes\n        else {\n          filters[key] = convertAndSanitizeFilters(value, schema);\n        }\n      }\n\n      // Handle operators\n      else if (['$null', '$notNull'].includes(key)) {\n        filters[key] = parseType({ type: 'boolean', value: filters[key], forceCast: true });\n      } else if (isObject(value)) {\n        filters[key] = convertAndSanitizeFilters(value, schema);\n      }\n\n      // Remove empty objects & arrays\n      if (isPlainObject(filters[key]) && isEmpty(filters[key])) {\n        removeOperator(key);\n      }\n    }\n\n    return filters;\n  };\n\n  const convertStatusParams = (status?: 'draft' | 'published', query: Query = {}) => {\n    // NOTE: this is the query layer filters not the document/entity service filters\n    query.filters = ({ meta }: { meta: Model }) => {\n      const contentType = getModel(meta.uid);\n\n      // Ignore if target model has disabled DP, as it doesn't make sense to filter by its status\n      if (!contentType || !hasDraftAndPublish(contentType)) {\n        return {};\n      }\n\n      return { [PUBLISHED_AT_ATTRIBUTE]: { $null: status === 'draft' } };\n    };\n  };\n\n  const transformQueryParams = (uid: string, params: Params): Query => {\n    // NOTE: can be a CT, a Compo or nothing in the case of polymorphism (DZ & morph relations)\n    const schema = getModel(uid);\n\n    const query: Query = {};\n\n    const { _q, sort, filters, fields, populate, page, pageSize, start, limit, status, ...rest } =\n      params;\n\n    if (!isNil(status)) {\n      convertStatusParams(status, query);\n    }\n\n    if (!isNil(_q)) {\n      query._q = _q;\n    }\n\n    if (!isNil(sort)) {\n      query.orderBy = convertSortQueryParams(sort);\n    }\n\n    if (!isNil(filters)) {\n      query.where = convertFiltersQueryParams(filters, schema);\n    }\n\n    if (!isNil(fields)) {\n      query.select = convertFieldsQueryParams(fields);\n    }\n\n    if (!isNil(populate)) {\n      query.populate = convertPopulateQueryParams(populate, schema);\n    }\n\n    validatePaginationParams(page, pageSize, start, limit);\n\n    if (!isNil(page)) {\n      query.page = convertPageQueryParams(page);\n    }\n\n    if (!isNil(pageSize)) {\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\n    }\n\n    if (!isNil(start)) {\n      query.offset = convertStartQueryParams(start);\n    }\n\n    if (!isNil(limit)) {\n      query.limit = convertLimitQueryParams(limit);\n    }\n\n    return {\n      ...rest,\n      ...query,\n    };\n  };\n\n  return {\n    private_convertSortQueryParams: convertSortQueryParams,\n    private_convertStartQueryParams: convertStartQueryParams,\n    private_convertLimitQueryParams: convertLimitQueryParams,\n    private_convertPopulateQueryParams: convertPopulateQueryParams,\n    private_convertFiltersQueryParams: convertFiltersQueryParams,\n    private_convertFieldsQueryParams: convertFieldsQueryParams,\n    transformQueryParams,\n  };\n};\n\nexport { createTransformer };\n","import pMap from 'p-map';\nimport { curry } from 'lodash/fp';\n\ntype AnyFunc<TA extends any[] = any[], TR = any> = (...args: TA) => TR;\n\ntype MakeProm<T> = Promise<T extends PromiseLike<infer I> ? I : T>;\n\ntype PipedFunc<T extends AnyFunc[]> =\n  PipeReturn<T> extends never ? never : (...args: Parameters<T[0]>) => PipeReturn<T>;\n\ntype PipeReturn<F extends AnyFunc[]> = MakeProm<ReturnType<F[0]>>;\n\nexport function pipe<T extends AnyFunc[]>(...fns: PipeReturn<T> extends never ? never : T) {\n  const [firstFn, ...fnRest] = fns;\n\n  return (async (...args: any[]) => {\n    let res = await firstFn.apply(firstFn, args);\n\n    for (let i = 0; i < fnRest.length; i += 1) {\n      res = await fnRest[i](res);\n    }\n\n    return res;\n  }) as PipedFunc<T>;\n}\n\nexport const map = curry(pMap);\n\nexport const reduce =\n  (mixedArray: any[]) =>\n  async <T>(iteratee: AnyFunc, initialValue?: T) => {\n    let acc = initialValue;\n    for (let i = 0; i < mixedArray.length; i += 1) {\n      acc = await iteratee(acc, await mixedArray[i], i);\n    }\n    return acc;\n  };\n","import type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (attribute?.type === 'password') {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isPrivateAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, attribute }, { remove }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isBoolean } from 'lodash/fp';\nimport type { Attribute, Model } from './types';\n\nimport { isRelationalAttribute } from './content-types';\n\nconst MANY_RELATIONS = ['oneToMany', 'manyToMany'];\n\nconst getRelationalFields = (contentType: Model) => {\n  return Object.keys(contentType.attributes).filter((attributeName) => {\n    return contentType.attributes[attributeName].type === 'relation';\n  });\n};\n\nconst isOneToAny = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToOne', 'oneToMany'].includes(attribute.relation);\nconst isManyToAny = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['manyToMany', 'manyToOne'].includes(attribute.relation);\nconst isAnyToOne = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToOne', 'manyToOne'].includes(attribute.relation);\nconst isAnyToMany = (attribute: Attribute) =>\n  isRelationalAttribute(attribute) && ['oneToMany', 'manyToMany'].includes(attribute.relation);\n\nexport const constants = {\n  MANY_RELATIONS,\n};\n\n// Valid keys in the `options` property of relations reordering\n// The value for each key must be a function that returns true if it is a valid value\nexport const VALID_RELATION_ORDERING_KEYS: { [key: string]: (value: any) => boolean } = {\n  strict: isBoolean,\n};\n\nexport { getRelationalFields, isOneToAny, isManyToAny, isAnyToOne, isAnyToMany };\n","import { isArray, isObject } from 'lodash/fp';\nimport * as contentTypeUtils from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\nimport { RelationOrderingOptions } from '../../types';\nimport { VALID_RELATION_ORDERING_KEYS } from '../../relations';\n\nconst ACTIONS_TO_VERIFY = ['find'];\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\n\ntype MorphArray = Array<{ __type: string }>;\n\nexport default (auth: unknown): Visitor =>\n  async ({ data, key, attribute, schema }, { remove, set }) => {\n    if (!attribute) {\n      return;\n    }\n\n    const isRelation = attribute.type === 'relation';\n\n    if (!isRelation) {\n      return;\n    }\n\n    const handleMorphRelation = async () => {\n      const elements: any = (data as Record<string, MorphArray>)[key];\n\n      if ('connect' in elements || 'set' in elements || 'disconnect' in elements) {\n        const newValue: Record<string, unknown> = {};\n\n        const connect = await handleMorphElements(elements.connect || []);\n        const relSet = await handleMorphElements(elements.set || []);\n        const disconnect = await handleMorphElements(elements.disconnect || []);\n\n        if (connect.length > 0) {\n          newValue.connect = connect;\n        }\n\n        if (relSet.length > 0) {\n          newValue.set = relSet;\n        }\n\n        if (disconnect.length > 0) {\n          newValue.disconnect = disconnect;\n        }\n\n        // TODO: this should technically be in its own visitor to check morph options, but for now we'll handle it here\n        if (\n          'options' in elements &&\n          typeof elements.options === 'object' &&\n          elements.options !== null\n        ) {\n          const filteredOptions: RelationOrderingOptions = {};\n\n          // Iterate through the keys of elements.options\n          Object.keys(elements.options).forEach((key) => {\n            const validator = VALID_RELATION_ORDERING_KEYS[key as keyof RelationOrderingOptions];\n\n            // Ensure the key exists in VALID_RELATION_ORDERING_KEYS and the validator is defined before calling it\n            if (validator && validator(elements.options[key])) {\n              filteredOptions[key as keyof RelationOrderingOptions] = elements.options[key];\n            }\n          });\n\n          // Assign the filtered options back to newValue\n          newValue.options = filteredOptions;\n        }\n\n        set(key, newValue);\n      } else {\n        const newMorphValue = await handleMorphElements(elements);\n\n        // If the new value is empty, remove the relation completely\n        if (newMorphValue.length === 0) {\n          remove(key);\n        } else {\n          set(key, newMorphValue);\n        }\n      }\n    };\n\n    const handleMorphElements = async (elements: any[]) => {\n      const allowedElements: Record<string, unknown>[] = [];\n\n      if (!isArray(elements)) {\n        return allowedElements;\n      }\n\n      for (const element of elements) {\n        if (!isObject(element) || !('__type' in element)) {\n          continue;\n        }\n\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n        if (isAllowed) {\n          allowedElements.push(element);\n        }\n      }\n\n      return allowedElements;\n    };\n\n    const handleRegularRelation = async () => {\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\n\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n      // If the authenticated user don't have access to any of the scopes, then remove the field\n      if (!isAllowed) {\n        remove(key);\n      }\n    };\n\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\n\n    // Polymorphic relations\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\n      await handleMorphRelation();\n      return;\n    }\n\n    // Creator relations\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\n      // do nothing\n      return;\n    }\n\n    // Regular relations\n    await handleRegularRelation();\n  };\n\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\n  for (const scope of scopes) {\n    try {\n      await strapi.auth.verify(auth, { scope });\n      return true;\n    } catch {\n      continue;\n    }\n  }\n\n  return false;\n};\n","import { isMorphToRelationalAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (isMorphToRelationalAttribute(attribute)) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isDynamicZoneAttribute } from '../../content-types';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\n  if (isDynamicZoneAttribute(attribute)) {\n    remove(key);\n  }\n};\n\nexport default visitor;\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\n\nexport default (allowedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }, { remove }) => {\n    // All fields are allowed\n    if (allowedFields === null) {\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\n      );\n    }\n\n    if (isNil(path)) {\n      return;\n    }\n\n    const containedPaths = getContainedPaths(path);\n\n    /**\n     * Tells if the current path should be kept or not based\n     * on the success of the check functions for any of the allowed paths.\n     *\n     * The check functions are defined as follow:\n     *\n     * `containedPaths.includes(p)`\n     * @example\n     * ```js\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match but isn't handled by this check\n     * ```\n     *\n     * `p.startsWith(`${path}.`)`\n     * @example\n     * ```js\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match but isn't handled by this check\n     * ```\n     */\n    const isPathAllowed = allowedFields.some(\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\n    );\n\n    if (isPathAllowed) {\n      return;\n    }\n\n    // Remove otherwise\n    remove(key);\n  };\n\n/**\n * Retrieve the list of allowed paths based on the given path\n *\n * @example\n * ```js\n * const containedPaths = getContainedPaths('foo');\n * // ['foo']\n *\n *  * const containedPaths = getContainedPaths('foo.bar');\n * // ['foo', 'foo.bar']\n *\n *  * const containedPaths = getContainedPaths('foo.bar.field');\n * // ['foo', 'foo.bar', 'foo.bar.field']\n * ```\n */\nconst getContainedPaths = (path: string) => {\n  const parts = toPath(path);\n\n  return parts.reduce((acc, value, index, list) => {\n    return [...acc, list.slice(0, index + 1).join('.')];\n  }, [] as string[]);\n};\n","import { isArray, isString } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\n\nexport default (restrictedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }, { remove }) => {\n    // Remove all fields\n    if (restrictedFields === null) {\n      remove(key);\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\n      );\n    }\n\n    // Remove if an exact match was found\n    if (restrictedFields.includes(path as string)) {\n      remove(key);\n      return;\n    }\n\n    // Remove nested matches\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\n      path?.toString().startsWith(`${allowedPath}.`)\n    );\n    if (isRestrictedNested) {\n      remove(key);\n    }\n  };\n","import type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, value }, { set }) => {\n  if (key === '' && value === '*') {\n    const { attributes } = schema;\n\n    const newPopulateQuery = Object.entries(attributes)\n      .filter(([, attribute]) =>\n        ['relation', 'component', 'media', 'dynamiczone'].includes(attribute.type)\n      )\n      .reduce<Record<string, true>>((acc, [key]) => ({ ...acc, [key]: true }), {});\n\n    set('', newPopulateQuery);\n  }\n};\n\nexport default visitor;\n","/* eslint-disable @typescript-eslint/no-loop-func */\nimport { isNil, pick } from 'lodash/fp';\n\nimport {\n  AnyAttribute,\n  Attribute,\n  ComponentAttribute,\n  DynamicZoneAttribute,\n  Model,\n  RelationalAttribute,\n} from '../types';\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n}\n\nexport interface Parent {\n  attribute?: Attribute;\n  key: string | null;\n  path: Path;\n  schema: Model;\n}\n\nexport interface TraverseOptions {\n  schema: Model;\n  path?: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport interface VisitorOptions {\n  data: unknown;\n  value: unknown;\n  schema: Model;\n  key: string;\n  attribute?: AnyAttribute;\n  path: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport type Traverse = (\n  visitor: Visitor,\n  options: TraverseOptions,\n  data: unknown\n) => Promise<unknown>;\n\nexport interface Visitor {\n  (visitorOptions: VisitorOptions, opts: Pick<TransformUtils, 'set' | 'remove'>): void;\n}\n\ninterface Interceptor<T = unknown> {\n  predicate(data: unknown): data is T;\n  handler(\n    visitor: Visitor,\n    options: TraverseOptions,\n    data: T,\n    recurseOptions: { recurse: Traverse }\n  ): void;\n}\n\ninterface ParseUtils<T> {\n  transform(data: T): unknown;\n  remove(key: string, data: T): unknown;\n  set(key: string, value: unknown, data: T): unknown;\n  keys(data: T): string[];\n  get(key: string, data: T): unknown;\n}\n\ninterface Parser<T = unknown> {\n  predicate(data: unknown): data is T;\n  parser(data: T): ParseUtils<T>;\n}\n\ninterface Ignore {\n  (ctx: Context): boolean;\n}\n\ninterface AttributeHandler<AttributeType = Attribute> {\n  predicate(ctx: Context<AttributeType>): boolean;\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\n}\ninterface CommonHandler<AttributeType = Attribute> {\n  predicate(ctx: Context<AttributeType>): boolean;\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\n}\n\nexport interface TransformUtils {\n  remove(key: string): void;\n  set(key: string, value: unknown): void;\n  recurse: Traverse;\n}\n\ninterface Context<AttributeType = Attribute> {\n  key: string;\n  value: unknown;\n  attribute: AttributeType;\n  schema: Model;\n  path: Path;\n  data: unknown;\n  visitor: Visitor;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\ninterface State {\n  parsers: Parser[];\n  interceptors: Interceptor[];\n  ignore: Ignore[];\n  handlers: {\n    attributes: AttributeHandler[];\n    common: CommonHandler[];\n  };\n}\n\nconst DEFAULT_PATH = { raw: null, attribute: null } satisfies Path;\n\nexport default () => {\n  const state: State = {\n    parsers: [],\n    interceptors: [],\n    ignore: [],\n    handlers: {\n      attributes: [],\n      common: [],\n    },\n  };\n\n  const traverse: Traverse = async (visitor, options, data) => {\n    const { path = DEFAULT_PATH, parent, schema, getModel } = options ?? {};\n\n    // interceptors\n    for (const { predicate, handler } of state.interceptors) {\n      if (predicate(data)) {\n        return handler(visitor, options, data, { recurse: traverse });\n      }\n    }\n\n    // parsers\n    const parser = state.parsers.find((parser) => parser.predicate(data))?.parser;\n    const utils = parser?.(data);\n\n    // Return the data untouched if we don't know how to traverse it\n    if (!utils) {\n      return data;\n    }\n\n    // main loop\n    let out = utils.transform(data);\n    const keys = utils.keys(out);\n\n    for (const key of keys) {\n      const attribute = schema?.attributes?.[key];\n\n      const newPath = { ...path };\n\n      newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n\n      if (!isNil(attribute)) {\n        newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n      }\n\n      // visitors\n      const visitorOptions: VisitorOptions = {\n        key,\n        value: utils.get(key, out),\n        attribute,\n        schema,\n        path: newPath,\n        data: out,\n        getModel,\n        parent,\n      };\n\n      const transformUtils: TransformUtils = {\n        remove(key) {\n          out = utils.remove(key, out);\n        },\n        set(key, value) {\n          out = utils.set(key, value, out);\n        },\n        recurse: traverse,\n      };\n\n      await visitor(visitorOptions, pick(['remove', 'set'], transformUtils));\n\n      const value = utils.get(key, out);\n\n      const createContext = (): Context => ({\n        key,\n        value,\n        attribute,\n        schema,\n        path: newPath,\n        data: out,\n        visitor,\n        getModel,\n        parent,\n      });\n\n      // ignore\n      const ignoreCtx = createContext();\n      const shouldIgnore = state.ignore.some((predicate) => predicate(ignoreCtx));\n\n      if (shouldIgnore) {\n        continue;\n      }\n\n      // handlers\n      const handlers = [...state.handlers.common, ...state.handlers.attributes];\n\n      for await (const handler of handlers) {\n        const ctx = createContext();\n        const pass = await handler.predicate(ctx);\n\n        if (pass) {\n          await handler.handler(ctx, pick(['recurse', 'set'], transformUtils));\n        }\n      }\n    }\n\n    return out;\n  };\n\n  return {\n    traverse,\n\n    intercept<T>(predicate: Interceptor<T>['predicate'], handler: Interceptor<T>['handler']) {\n      state.interceptors.push({ predicate, handler });\n      return this;\n    },\n\n    parse<T>(predicate: Parser<T>['predicate'], parser: Parser<T>['parser']) {\n      state.parsers.push({ predicate, parser });\n      return this;\n    },\n\n    ignore(predicate: Ignore) {\n      state.ignore.push(predicate);\n      return this;\n    },\n\n    on(predicate: CommonHandler['predicate'], handler: CommonHandler['handler']) {\n      state.handlers.common.push({ predicate, handler });\n      return this;\n    },\n\n    onAttribute(predicate: AttributeHandler['predicate'], handler: AttributeHandler['handler']) {\n      state.handlers.attributes.push({ predicate, handler });\n      return this;\n    },\n\n    onRelation(handler: AttributeHandler<RelationalAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'relation', handler);\n    },\n\n    onMedia(handler: AttributeHandler<RelationalAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'media', handler);\n    },\n\n    onComponent(handler: AttributeHandler<ComponentAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'component', handler);\n    },\n\n    onDynamicZone(handler: AttributeHandler<DynamicZoneAttribute>['handler']) {\n      return this.onAttribute(({ attribute }) => attribute?.type === 'dynamiczone', handler);\n    },\n  };\n};\n","import { curry, isObject, isEmpty, isArray, isNil, cloneDeep, omit } from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst filters = traverseFactory()\n  .intercept(\n    // Intercept filters arrays and apply the traversal to each one individually\n    isArray,\n    async (visitor, options, filters, { recurse }) => {\n      return Promise.all(\n        filters.map((filter, i) => {\n          // In filters, only operators such as $and, $in, $notIn or $or and implicit operators like [...]\n          // can have a value array, thus we can update the raw path but not the attribute one\n          const newPath = options.path\n            ? { ...options.path, raw: `${options.path.raw}[${i}]` }\n            : options.path;\n\n          return recurse(visitor, { ...options, path: newPath }, filter);\n        })\n        // todo: move that to the visitors\n      ).then((res) => res.filter((val) => !(isObject(val) && isEmpty(val))));\n    }\n  )\n  .intercept(\n    // Ignore non object filters and return the value as-is\n    (filters): filters is unknown => !isObject(filters),\n    (_, __, filters) => {\n      return filters;\n    }\n  )\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      return omit(key, data);\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Ignore null or undefined values\n  .ignore(({ value }) => isNil(value))\n  // Recursion on operators (non attributes)\n  .on(\n    ({ attribute }) => isNil(attribute),\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      set(key, await recurse(visitor, { schema, path, getModel, parent }, value));\n    }\n  )\n  // Handle relation recursion\n  .onRelation(\n    async ({ key, attribute, visitor, path, value, schema, getModel }, { set, recurse }) => {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      if (isMorphRelation) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  .onComponent(\n    async ({ key, attribute, visitor, path, schema, value, getModel }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle media recursion\n  .onMedia(async ({ key, visitor, path, schema, attribute, value, getModel }, { set, recurse }) => {\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  });\n\nexport default curry(filters.traverse);\n","import {\n  curry,\n  isString,\n  isObject,\n  map,\n  trim,\n  split,\n  isEmpty,\n  flatten,\n  pipe,\n  isNil,\n  first,\n  cloneDeep,\n} from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\n\nconst ORDERS = { asc: 'asc', desc: 'desc' };\nconst ORDER_VALUES = Object.values(ORDERS);\n\nconst isSortOrder = (value: string) => ORDER_VALUES.includes(value.toLowerCase());\nconst isStringArray = (value: unknown): value is string[] =>\n  Array.isArray(value) && value.every(isString);\nconst isObjectArray = (value: unknown): value is object[] =>\n  Array.isArray(value) && value.every(isObject);\nconst isNestedSorts = (value: unknown): value is string =>\n  isString(value) && value.split(',').length > 1;\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst sort = traverseFactory()\n  .intercept(\n    // String with chained sorts (foo,bar,foobar) => split, map(recurse), then recompose\n    isNestedSorts,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(\n        sort\n          .split(',')\n          .map(trim)\n          .map((nestedSort) => recurse(visitor, options, nestedSort))\n      ).then((res) => res.filter((part) => !isEmpty(part)).join(','));\n    }\n  )\n  .intercept(\n    // Array of strings ['foo', 'foo,bar'] => map(recurse), then filter out empty items\n    isStringArray,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\n      );\n    }\n  )\n  .intercept(\n    // Array of objects [{ foo: 'asc' }, { bar: 'desc', baz: 'asc' }] => map(recurse), then filter out empty items\n    isObjectArray,\n    async (visitor, options, sort, { recurse }) => {\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\n      );\n    }\n  )\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = pipe(split('.'), map(split(':')), flatten);\n    const recompose = (parts: string[]) => {\n      if (parts.length === 0) {\n        return undefined;\n      }\n\n      return parts.reduce((acc, part) => {\n        if (isEmpty(part)) {\n          return acc;\n        }\n\n        if (acc === '') {\n          return part;\n        }\n\n        return isSortOrder(part) ? `${acc}:${part}` : `${acc}.${part}`;\n      }, '');\n    };\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Handle deep sort on relation\n  .onRelation(\n    async ({ key, value, attribute, visitor, path, getModel, schema }, { set, recurse }) => {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      if (isMorphRelation) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle deep sort on media\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  })\n  // Handle deep sort on components\n  .onComponent(\n    async ({ key, value, visitor, path, schema, attribute, getModel }, { recurse, set }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  );\n\nexport default curry(sort.traverse);\n","import {\n  curry,\n  isString,\n  isArray,\n  isEmpty,\n  split,\n  isObject,\n  trim,\n  constant,\n  isNil,\n  identity,\n  cloneDeep,\n  join,\n  first,\n} from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\nimport { Attribute } from '../types';\nimport { isMorphToRelationalAttribute } from '../content-types';\n\nconst isKeyword = (keyword: string) => {\n  return ({ key, attribute }: { key: string; attribute: Attribute }) => {\n    return !attribute && keyword === key;\n  };\n};\n\nconst isWildcard = (value: unknown): value is '*' => value === '*';\n\nconst isPopulateString = (value: unknown): value is string => {\n  return isString(value) && !isWildcard(value);\n};\n\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst populate = traverseFactory()\n  .intercept(isPopulateString, async (visitor, options, populate, { recurse }) => {\n    /**\n     * Ensure the populate clause its in the extended format ( { populate: { ... } }, and not just a string)\n     * This gives a consistent structure to track the \"parent\" node of each nested populate clause\n     */\n    const populateObject = pathsToObjectPopulate([populate]);\n    const traversedPopulate = (await recurse(visitor, options, populateObject)) as PopulateObject;\n    const [result] = objectPopulateToPaths(traversedPopulate);\n\n    return result;\n  })\n  // Array of strings ['foo', 'bar.baz'] => map(recurse), then filter out empty items\n  .intercept(isStringArray, async (visitor, options, populate, { recurse }) => {\n    const paths = await Promise.all(\n      populate.map((subClause) => recurse(visitor, options, subClause))\n    );\n\n    return paths.filter((item) => !isNil(item));\n  })\n  // for wildcard, generate custom utilities to modify the values\n  .parse(isWildcard, () => ({\n    /**\n     * Since value is '*', we don't need to transform it\n     */\n    transform: identity,\n\n    /**\n     * '*' isn't a key/value structure, so regardless\n     *  of the given key, it returns the data ('*')\n     */\n    get: (_key, data) => data,\n\n    /**\n     * '*' isn't a key/value structure, so regardless\n     * of the given `key`, use `value` as the new `data`\n     */\n    set: (_key, value) => value,\n\n    /**\n     * '*' isn't a key/value structure, but we need to simulate at least one to enable\n     * the data traversal. We're using '' since it represents a falsy string value\n     */\n    keys: constant(['']),\n\n    /**\n     * Removing '*' means setting it to undefined, regardless of the given key\n     */\n    remove: constant(undefined),\n  }))\n\n  // Parse string values\n  .parse(isString, () => {\n    const tokenize = split('.');\n    const recompose = join('.');\n\n    return {\n      transform: trim,\n\n      remove(key, data) {\n        const [root] = tokenize(data);\n\n        return root === key ? undefined : data;\n      },\n\n      set(key, value, data) {\n        const [root] = tokenize(data);\n\n        if (root !== key) {\n          return data;\n        }\n\n        return isNil(value) || isEmpty(value) ? root : `${root}.${value}`;\n      },\n\n      keys(data) {\n        const v = first(tokenize(data));\n        return v ? [v] : [];\n      },\n\n      get(key, data) {\n        const [root, ...rest] = tokenize(data);\n\n        return key === root ? recompose(rest) : undefined;\n      },\n    };\n  })\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      // eslint-disable-next-line no-unused-vars\n      const { [key]: ignored, ...rest } = data;\n\n      return rest;\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  .ignore(({ key, attribute }) => {\n    // we don't want to recurse using traversePopulate and instead let\n    // the visitors recurse with the appropriate traversal (sort, filters, etc...)\n    return ['sort', 'filters', 'fields'].includes(key) && !attribute;\n  })\n  .on(\n    // Handle recursion on populate.\"populate\"\n    isKeyword('populate'),\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      const newValue = await recurse(visitor, { schema, path, getModel, parent }, value);\n\n      set(key, newValue);\n    }\n  )\n  .on(\n    isKeyword('on'),\n    async ({ key, visitor, path, value, getModel, parent }, { set, recurse }) => {\n      const newOn: Record<string, unknown> = {};\n\n      if (!isObj(value)) {\n        return;\n      }\n\n      for (const [uid, subPopulate] of Object.entries(value)) {\n        const model = getModel(uid);\n        const newPath = { ...path, raw: `${path.raw}[${uid}]` };\n\n        newOn[uid] = await recurse(\n          visitor,\n          { schema: model, path: newPath, getModel, parent },\n          subPopulate\n        );\n      }\n\n      set(key, newOn);\n    }\n  )\n  // Handle populate on relation\n  .onRelation(\n    async ({ key, value, attribute, visitor, path, schema, getModel }, { set, recurse }) => {\n      if (isNil(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      if (isMorphToRelationalAttribute(attribute)) {\n        // Don't traverse values that cannot be parsed\n        if (!isObject(value) || !('on' in value && isObject(value?.on))) {\n          return;\n        }\n\n        // If there is a populate fragment defined, traverse it\n        const newValue = await recurse(\n          visitor,\n          { schema, path, getModel, parent },\n          { on: value?.on }\n        );\n\n        set(key, newValue);\n\n        return;\n      }\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle populate on media\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\n    if (isNil(value)) {\n      return;\n    }\n\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  })\n  // Handle populate on components\n  .onComponent(\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { recurse, set }) => {\n      if (isNil(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle populate on dynamic zones\n  .onDynamicZone(\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { set, recurse }) => {\n      if (isNil(value) || !isObject(value)) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      // Handle fragment syntax\n      if ('on' in value && value.on) {\n        const newOn = await recurse(visitor, { schema, path, getModel, parent }, { on: value.on });\n\n        set(key, newOn);\n      }\n    }\n  );\n\nexport default curry(populate.traverse);\n\ntype PopulateObject = {\n  [key: string]: true | { populate: PopulateObject };\n};\n\nconst objectPopulateToPaths = (input: PopulateObject): string[] => {\n  const paths: string[] = [];\n\n  function traverse(currentObj: PopulateObject, parentPath: string) {\n    for (const [key, value] of Object.entries(currentObj)) {\n      const currentPath = parentPath ? `${parentPath}.${key}` : key;\n      if (value === true) {\n        paths.push(currentPath);\n      } else {\n        traverse((value as { populate: PopulateObject }).populate, currentPath);\n      }\n    }\n  }\n\n  traverse(input, '');\n\n  return paths;\n};\n\nconst pathsToObjectPopulate = (input: string[]): PopulateObject => {\n  const result: PopulateObject = {};\n\n  function traverse(object: PopulateObject, keys: string[]): void {\n    const [first, ...rest] = keys;\n    if (rest.length === 0) {\n      object[first] = true;\n    } else {\n      if (!object[first] || typeof object[first] === 'boolean') {\n        object[first] = { populate: {} };\n      }\n      traverse((object[first] as { populate: PopulateObject }).populate, rest);\n    }\n  }\n\n  input.forEach((clause) => traverse(result, clause.split('.')));\n\n  return result;\n};\n","import { curry, isArray, isString, eq, trim, constant } from 'lodash/fp';\n\nimport traverseFactory from './factory';\n\nconst isStringArray = (value: unknown): value is string[] => {\n  return isArray(value) && value.every(isString);\n};\n\nconst fields = traverseFactory()\n  // Intercept array of strings\n  // e.g. fields=['title', 'description']\n  .intercept(isStringArray, async (visitor, options, fields, { recurse }) => {\n    return Promise.all(fields.map((field) => recurse(visitor, options, field)));\n  })\n  // Intercept comma separated fields (as string)\n  // e.g. fields='title,description'\n  .intercept(\n    (value): value is string => isString(value) && value.includes(','),\n    (visitor, options, fields, { recurse }) => {\n      return Promise.all(fields.split(',').map((field) => recurse(visitor, options, field)));\n    }\n  )\n  // Return wildcards as is\n  .intercept((value): value is string => eq('*', value), constant('*'))\n  // Parse string values\n  // Since we're parsing strings only, each value should be an attribute name (and it's value, undefined),\n  // thus it shouldn't be possible to set a new value, and get should return the whole data if key === data\n  .parse(isString, () => ({\n    transform: trim,\n\n    remove(key, data) {\n      return data === key ? undefined : data;\n    },\n\n    set(_key, _value, data) {\n      return data;\n    },\n\n    keys(data) {\n      return [data];\n    },\n\n    get(key, data) {\n      return key === data ? data : undefined;\n    },\n  }));\n\nexport default curry(fields.traverse);\n","import { curry, isEmpty, isNil, isArray, isObject } from 'lodash/fp';\n\nimport { pipe as pipeAsync } from '../async';\nimport traverseEntity from '../traverse-entity';\nimport { isScalarAttribute, constants } from '../content-types';\n\nimport {\n  traverseQueryFilters,\n  traverseQuerySort,\n  traverseQueryPopulate,\n  traverseQueryFields,\n} from '../traverse';\n\nimport {\n  removePassword,\n  removePrivate,\n  removeDynamicZones,\n  removeMorphToRelations,\n  expandWildcardPopulate,\n} from './visitors';\nimport { isOperator } from '../operators';\n\nimport type { Model, Data } from '../types';\nimport type { Parent } from '../traverse/factory';\n\ninterface Context {\n  schema: Model;\n  getModel: (model: string) => Model;\n  parent?: Parent;\n}\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\n\nconst sanitizePasswords = (ctx: Context) => async (entity: Data) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in sanitizePasswords');\n  }\n\n  return traverseEntity(removePassword, ctx, entity);\n};\n\nconst defaultSanitizeOutput = async (ctx: Context, entity: Data) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeOutput');\n  }\n\n  return traverseEntity(\n    (...args) => {\n      removePassword(...args);\n      removePrivate(...args);\n    },\n    ctx,\n    entity\n  );\n};\n\nconst defaultSanitizeFilters = curry((ctx: Context, filters: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeFilters');\n  }\n\n  return pipeAsync(\n    // Remove keys that are not attributes or valid operators\n    traverseQueryFilters(({ key, attribute }, { remove }) => {\n      const isAttribute = !!attribute;\n\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not checking it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (!isAttribute && !isOperator(key)) {\n        remove(key);\n      }\n    }, ctx),\n    // Remove dynamic zones from filters\n    traverseQueryFilters(removeDynamicZones, ctx),\n    // Remove morpTo relations from filters\n    traverseQueryFilters(removeMorphToRelations, ctx),\n    // Remove passwords from filters\n    traverseQueryFilters(removePassword, ctx),\n    // Remove private from filters\n    traverseQueryFilters(removePrivate, ctx),\n    // Remove empty objects\n    traverseQueryFilters(({ key, value }, { remove }) => {\n      if (isObject(value) && isEmpty(value)) {\n        remove(key);\n      }\n    }, ctx)\n  )(filters);\n});\n\nconst defaultSanitizeSort = curry((ctx: Context, sort: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeSort');\n  }\n\n  return pipeAsync(\n    // Remove non attribute keys\n    traverseQuerySort(({ key, attribute }, { remove }) => {\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not checking it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (!attribute) {\n        remove(key);\n      }\n    }, ctx),\n    // Remove dynamic zones from sort\n    traverseQuerySort(removeDynamicZones, ctx),\n    // Remove morpTo relations from sort\n    traverseQuerySort(removeMorphToRelations, ctx),\n    // Remove private from sort\n    traverseQuerySort(removePrivate, ctx),\n    // Remove passwords from filters\n    traverseQuerySort(removePassword, ctx),\n    // Remove keys for empty non-scalar values\n    traverseQuerySort(({ key, attribute, value }, { remove }) => {\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not removing it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (!isScalarAttribute(attribute) && isEmpty(value)) {\n        remove(key);\n      }\n    }, ctx)\n  )(sort);\n});\n\nconst defaultSanitizeFields = curry((ctx: Context, fields: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizeFields');\n  }\n\n  return pipeAsync(\n    // Only keep scalar attributes\n    traverseQueryFields(({ key, attribute }, { remove }) => {\n      // ID is not an attribute per se, so we need to make\n      // an extra check to ensure we're not checking it\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n        return;\n      }\n\n      if (isNil(attribute) || !isScalarAttribute(attribute)) {\n        remove(key);\n      }\n    }, ctx),\n    // Remove private fields\n    traverseQueryFields(removePrivate, ctx),\n    // Remove password fields\n    traverseQueryFields(removePassword, ctx),\n    // Remove nil values from fields array\n    (value) => (isArray(value) ? value.filter((field) => !isNil(field)) : value)\n  )(fields);\n});\n\nconst defaultSanitizePopulate = curry((ctx: Context, populate: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultSanitizePopulate');\n  }\n\n  return pipeAsync(\n    traverseQueryPopulate(expandWildcardPopulate, ctx),\n    traverseQueryPopulate(async ({ key, value, schema, attribute, getModel, path }, { set }) => {\n      if (attribute) {\n        return;\n      }\n\n      const parent = { key, path, schema, attribute } satisfies Parent;\n\n      if (key === 'sort') {\n        set(key, await defaultSanitizeSort({ schema, getModel, parent }, value));\n      }\n\n      if (key === 'filters') {\n        set(key, await defaultSanitizeFilters({ schema, getModel, parent }, value));\n      }\n\n      if (key === 'fields') {\n        set(key, await defaultSanitizeFields({ schema, getModel, parent }, value));\n      }\n\n      if (key === 'populate') {\n        set(key, await defaultSanitizePopulate({ schema, getModel, parent }, value));\n      }\n    }, ctx),\n    // Remove private fields\n    traverseQueryPopulate(removePrivate, ctx)\n  )(populate);\n});\n\nexport {\n  sanitizePasswords,\n  defaultSanitizeOutput,\n  defaultSanitizeFilters,\n  defaultSanitizeSort,\n  defaultSanitizeFields,\n  defaultSanitizePopulate,\n};\n","import { CurriedFunction1 } from 'lodash';\nimport { isArray, cloneDeep, omit } from 'lodash/fp';\n\nimport { constants, getNonWritableAttributes } from '../content-types';\nimport { pipe as pipeAsync } from '../async';\n\nimport * as visitors from './visitors';\nimport * as sanitizers from './sanitizers';\nimport traverseEntity from '../traverse-entity';\n\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\nimport type { Model, Data } from '../types';\n\nexport interface Options {\n  auth?: unknown;\n}\n\nexport interface Sanitizer {\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\n}\nexport interface SanitizeFunc {\n  (data: unknown, schema: Model, options?: Options): Promise<unknown>;\n}\n\nexport interface APIOptions {\n  sanitizers?: Sanitizers;\n  getModel: (model: string) => Model;\n}\n\nexport interface Sanitizers {\n  input?: Sanitizer[];\n  output?: Sanitizer[];\n}\n\nconst createAPISanitizers = (opts: APIOptions) => {\n  const { getModel } = opts;\n\n  const sanitizeInput: SanitizeFunc = (data: unknown, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeInput');\n    }\n    if (isArray(data)) {\n      return Promise.all(data.map((entry) => sanitizeInput(entry, schema, { auth })));\n    }\n\n    const nonWritableAttributes = getNonWritableAttributes(schema);\n\n    const transforms = [\n      // Remove first level ID in inputs\n      omit(constants.ID_ATTRIBUTE),\n      omit(constants.DOC_ID_ATTRIBUTE),\n      // Remove non-writable attributes\n      traverseEntity(visitors.removeRestrictedFields(nonWritableAttributes), { schema, getModel }),\n    ];\n\n    if (auth) {\n      // Remove restricted relations\n      transforms.push(\n        traverseEntity(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    // Apply sanitizers from registry if exists\n    opts?.sanitizers?.input?.forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\n\n    return pipeAsync(...transforms)(data as Data);\n  };\n\n  const sanitizeOutput: SanitizeFunc = async (data, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeOutput');\n    }\n    if (isArray(data)) {\n      const res = new Array(data.length);\n      for (let i = 0; i < data.length; i += 1) {\n        res[i] = await sanitizeOutput(data[i], schema, { auth });\n      }\n      return res;\n    }\n\n    const transforms = [\n      (data: Data) => sanitizers.defaultSanitizeOutput({ schema, getModel }, data),\n    ];\n\n    if (auth) {\n      transforms.push(\n        traverseEntity(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    // Apply sanitizers from registry if exists\n    opts?.sanitizers?.output?.forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\n\n    return pipeAsync(...transforms)(data as Data);\n  };\n\n  const sanitizeQuery = async (\n    query: Record<string, unknown>,\n    schema: Model,\n    { auth }: Options = {}\n  ) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeQuery');\n    }\n    const { filters, sort, fields, populate } = query;\n\n    const sanitizedQuery = cloneDeep(query);\n\n    if (filters) {\n      Object.assign(sanitizedQuery, { filters: await sanitizeFilters(filters, schema, { auth }) });\n    }\n\n    if (sort) {\n      Object.assign(sanitizedQuery, { sort: await sanitizeSort(sort, schema, { auth }) });\n    }\n\n    if (fields) {\n      Object.assign(sanitizedQuery, { fields: await sanitizeFields(fields, schema) });\n    }\n\n    if (populate) {\n      Object.assign(sanitizedQuery, { populate: await sanitizePopulate(populate, schema) });\n    }\n\n    return sanitizedQuery;\n  };\n\n  const sanitizeFilters: SanitizeFunc = (filters, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeFilters');\n    }\n    if (isArray(filters)) {\n      return Promise.all(filters.map((filter) => sanitizeFilters(filter, schema, { auth })));\n    }\n\n    const transforms = [sanitizers.defaultSanitizeFilters({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryFilters(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    return pipeAsync(...transforms)(filters);\n  };\n\n  const sanitizeSort: SanitizeFunc = (sort, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeSort');\n    }\n    const transforms = [sanitizers.defaultSanitizeSort({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQuerySort(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    return pipeAsync(...transforms)(sort);\n  };\n\n  const sanitizeFields: SanitizeFunc = (fields, schema: Model) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizeFields');\n    }\n    const transforms = [sanitizers.defaultSanitizeFields({ schema, getModel })];\n\n    return pipeAsync(...transforms)(fields);\n  };\n\n  const sanitizePopulate: SanitizeFunc = (populate, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizePopulate');\n    }\n    const transforms = [sanitizers.defaultSanitizePopulate({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryPopulate(visitors.removeRestrictedRelations(auth), { schema, getModel })\n      );\n    }\n\n    return pipeAsync(...transforms)(populate);\n  };\n\n  return {\n    input: sanitizeInput,\n    output: sanitizeOutput,\n    query: sanitizeQuery,\n    filters: sanitizeFilters,\n    sort: sanitizeSort,\n    fields: sanitizeFields,\n    populate: sanitizePopulate,\n  };\n};\n\nexport { createAPISanitizers, sanitizers, visitors };\n\nexport type APISanitiers = ReturnType<typeof createAPISanitizers>;\n","import { ValidationError } from '../errors';\n\nexport const throwInvalidKey = ({ key, path }: { key: string; path?: string | null }): never => {\n  const msg = path && path !== key ? `Invalid key ${key} at ${path}` : `Invalid key ${key}`;\n\n  throw new ValidationError(msg, {\n    key,\n    path,\n  });\n};\n\n// lodash/fp curry does not detect async methods, so we'll use our own that is typed correctly\nexport const asyncCurry = <A extends unknown[], R>(\n  fn: (...args: A) => Promise<R>\n): ((...args: Partial<A>) => any) => {\n  const curried = (...args: unknown[]): unknown => {\n    if (args.length >= fn.length) {\n      return fn(...(args as A));\n    }\n    return (...moreArgs: unknown[]) => curried(...args, ...moreArgs);\n  };\n\n  return curried;\n};\n","import { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute, path }) => {\n  if (attribute?.type === 'password') {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isPrivateAttribute } from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ schema, key, attribute, path }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isArray, isObject } from 'lodash/fp';\nimport * as contentTypeUtils from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\nimport { VALID_RELATION_ORDERING_KEYS } from '../../relations';\n\nconst ACTIONS_TO_VERIFY = ['find'];\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\n\ntype MorphArray = Array<{ __type: string }>;\n\nexport default (auth: unknown): Visitor =>\n  async ({ data, key, attribute, schema, path }) => {\n    if (!attribute) {\n      return;\n    }\n\n    const isRelation = attribute.type === 'relation';\n\n    if (!isRelation) {\n      return;\n    }\n\n    const handleMorphRelation = async () => {\n      const elements: any = (data as Record<string, MorphArray>)[key];\n\n      if (\n        'connect' in elements ||\n        'set' in elements ||\n        'disconnect' in elements ||\n        'options' in elements\n      ) {\n        await handleMorphElements(elements.connect || []);\n        await handleMorphElements(elements.set || []);\n        await handleMorphElements(elements.disconnect || []);\n\n        // TODO: this should technically be in its own visitor to check morph options, but for now we'll handle it here\n        if ('options' in elements) {\n          if (elements.options === null || elements.options === undefined) {\n            return;\n          }\n\n          if (typeof elements.options !== 'object') {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n\n          const optionKeys = Object.keys(elements.options);\n\n          // Validate each key based on its validator function\n          for (const key of optionKeys) {\n            if (!(key in VALID_RELATION_ORDERING_KEYS)) {\n              throwInvalidKey({ key, path: path.attribute });\n            }\n            if (!VALID_RELATION_ORDERING_KEYS[key](elements.options[key])) {\n              throwInvalidKey({ key, path: path.attribute });\n            }\n          }\n        }\n      } else {\n        await handleMorphElements(elements);\n      }\n    };\n\n    const handleMorphElements = async (elements: any[]) => {\n      if (!isArray(elements)) {\n        throwInvalidKey({ key, path: path.attribute });\n      }\n\n      for (const element of elements) {\n        if (!isObject(element) || !('__type' in element)) {\n          throwInvalidKey({ key, path: path.attribute });\n        }\n\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n        if (!isAllowed) {\n          throwInvalidKey({ key, path: path.attribute });\n        }\n      }\n    };\n\n    const handleRegularRelation = async () => {\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\n\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\n\n      // If the authenticated user don't have access to any of the scopes\n      if (!isAllowed) {\n        throwInvalidKey({ key, path: path.attribute });\n      }\n    };\n\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\n\n    // Polymorphic relations\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\n      await handleMorphRelation();\n      return;\n    }\n\n    // Creator relations\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\n      // do nothing\n      return;\n    }\n\n    // Regular relations\n    await handleRegularRelation();\n  };\n\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\n  for (const scope of scopes) {\n    try {\n      await strapi.auth.verify(auth, { scope });\n      return true;\n    } catch {\n      continue;\n    }\n  }\n\n  return false;\n};\n","import { isMorphToRelationalAttribute } from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute, path }) => {\n  if (isMorphToRelationalAttribute(attribute)) {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isDynamicZoneAttribute } from '../../content-types';\nimport { throwInvalidKey } from '../utils';\nimport type { Visitor } from '../../traverse/factory';\n\nconst visitor: Visitor = ({ key, attribute, path }) => {\n  if (isDynamicZoneAttribute(attribute)) {\n    throwInvalidKey({ key, path: path.attribute });\n  }\n};\n\nexport default visitor;\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\nimport { throwInvalidKey } from '../utils';\n\nexport default (allowedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }) => {\n    // All fields are allowed\n    if (allowedFields === null) {\n      return;\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\n      );\n    }\n\n    if (isNil(path)) {\n      return;\n    }\n\n    const containedPaths = getContainedPaths(path);\n\n    /**\n     * Tells if the current path should be kept or not based\n     * on the success of the check functions for any of the allowed paths.\n     *\n     * The check functions are defined as follow:\n     *\n     * `containedPaths.includes(p)`\n     * @example\n     * ```js\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match but isn't handled by this check\n     * ```\n     *\n     * `p.startsWith(`${path}.`)`\n     * @example\n     * ```js\n     * const path = 'foo.bar';\n     * const p = 'foo.bar.field';\n     * // it should match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'bar.foo';\n     * // it shouldn't match\n     *\n     * const path = 'foo.bar.field';\n     * const p = 'foo.bar';\n     * // it should match but isn't handled by this check\n     * ```\n     */\n    const isPathAllowed = allowedFields.some(\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\n    );\n\n    if (isPathAllowed) {\n      return;\n    }\n\n    // throw otherwise\n    throwInvalidKey({ key, path });\n  };\n\n/**\n * Retrieve the list of allowed paths based on the given path\n *\n * @example\n * ```js\n * const containedPaths = getContainedPaths('foo');\n * // ['foo']\n *\n *  * const containedPaths = getContainedPaths('foo.bar');\n * // ['foo', 'foo.bar']\n *\n *  * const containedPaths = getContainedPaths('foo.bar.field');\n * // ['foo', 'foo.bar', 'foo.bar.field']\n * ```\n */\nconst getContainedPaths = (path: string) => {\n  const parts = toPath(path);\n\n  return parts.reduce((acc, value, index, list) => {\n    return [...acc, list.slice(0, index + 1).join('.')];\n  }, [] as string[]);\n};\n","import { isArray, isString } from 'lodash/fp';\nimport type { Visitor } from '../../traverse/factory';\nimport { throwInvalidKey } from '../utils';\n\nexport default (restrictedFields: string[] | null = null): Visitor =>\n  ({ key, path: { attribute: path } }) => {\n    // all fields\n    if (restrictedFields === null) {\n      throwInvalidKey({ key, path });\n    }\n\n    // Throw on invalid formats\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\n      throw new TypeError(\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\n      );\n    }\n\n    // if an exact match was found\n    if (restrictedFields.includes(path as string)) {\n      throwInvalidKey({ key, path });\n    }\n\n    // nested matches\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\n      path?.toString().startsWith(`${allowedPath}.`)\n    );\n    if (isRestrictedNested) {\n      throwInvalidKey({ key, path });\n    }\n  };\n","import {\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isRelationalAttribute,\n  constants,\n  isComponentSchema,\n  isMediaAttribute,\n  hasRelationReordering,\n} from '../../content-types';\nimport type { Visitor } from '../../traverse-entity';\nimport { throwInvalidKey } from '../utils';\n\n// TODO these should all be centralized somewhere instead of maintaining a list\nconst ID_FIELDS = [constants.DOC_ID_ATTRIBUTE, constants.DOC_ID_ATTRIBUTE];\nconst ALLOWED_ROOT_LEVEL_FIELDS = [...ID_FIELDS];\nconst MORPH_TO_ALLOWED_FIELDS = ['__type'];\nconst DYNAMIC_ZONE_ALLOWED_FIELDS = ['__component'];\nconst RELATION_REORDERING_FIELDS = ['connect', 'disconnect', 'set', 'options'];\n\nconst throwUnrecognizedFields: Visitor = ({ key, attribute, path, schema, parent }) => {\n  // We only look at properties that are not attributes\n  if (attribute) {\n    return;\n  }\n\n  // At root level (path.attribute === null), only accept allowed fields\n  if (path.attribute === null) {\n    if (ALLOWED_ROOT_LEVEL_FIELDS.includes(key)) {\n      return;\n    }\n\n    return throwInvalidKey({ key, path: attribute });\n  }\n\n  // allow special morphTo keys\n  if (isMorphToRelationalAttribute(parent?.attribute) && MORPH_TO_ALLOWED_FIELDS.includes(key)) {\n    return;\n  }\n\n  // allow special dz keys\n  if (\n    isComponentSchema(schema) &&\n    isDynamicZoneAttribute(parent?.attribute) &&\n    DYNAMIC_ZONE_ALLOWED_FIELDS.includes(key)\n  ) {\n    return;\n  }\n\n  // allow special relation reordering keys in manyToX and XtoMany relations\n  if (hasRelationReordering(parent?.attribute) && RELATION_REORDERING_FIELDS.includes(key)) {\n    return;\n  }\n\n  // allow id fields where it is needed for setting a relational id rather than trying to create with a given id\n  const canUseID = isRelationalAttribute(parent?.attribute) || isMediaAttribute(parent?.attribute);\n  if (canUseID && !ID_FIELDS.includes(key)) {\n    return;\n  }\n\n  // if we couldn't find any reason for it to be here, throw\n  throwInvalidKey({ key, path: attribute });\n};\n\nexport default throwUnrecognizedFields;\n","import { isEmpty, isNil, isObject } from 'lodash/fp';\n\nimport { pipe as pipeAsync } from '../async';\nimport { isScalarAttribute, constants } from '../content-types';\nimport {\n  traverseQueryFilters,\n  traverseQuerySort,\n  traverseQueryFields,\n  traverseQueryPopulate,\n} from '../traverse';\nimport { throwPassword, throwPrivate, throwDynamicZones, throwMorphToRelations } from './visitors';\nimport { isOperator } from '../operators';\nimport { asyncCurry, throwInvalidKey } from './utils';\nimport type { Model } from '../types';\nimport parseType from '../parse-type';\nimport type { Parent, Path } from '../traverse/factory';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\n\ninterface Context {\n  schema: Model;\n  getModel: (model: string) => Model;\n}\n\ninterface PopulateContext extends Context {\n  path?: Path;\n  parent?: Parent;\n}\n\ntype AnyFunc = (...args: any[]) => any;\n\nexport const FILTER_TRAVERSALS = [\n  'nonAttributesOperators',\n  'dynamicZones',\n  'morphRelations',\n  'passwords',\n  'private',\n];\n\nexport const validateFilters = asyncCurry(\n  async (ctx: Context, filters: unknown, include: (typeof FILTER_TRAVERSALS)[number][]) => {\n    // TODO: schema checks should check that it is a valid schema with yup\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidateFilters');\n    }\n\n    // Build the list of functions conditionally\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // keys that are not attributes or valid operators\n    if (include.includes('nonAttributesOperators')) {\n      functionsToApply.push(\n        traverseQueryFilters(({ key, attribute, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not removing it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          const isAttribute = !!attribute;\n\n          if (!isAttribute && !isOperator(key)) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    if (include.includes('dynamicZones')) {\n      functionsToApply.push(traverseQueryFilters(throwDynamicZones, ctx));\n    }\n\n    if (include.includes('morphRelations')) {\n      functionsToApply.push(traverseQueryFilters(throwMorphToRelations, ctx));\n    }\n\n    if (include.includes('passwords')) {\n      functionsToApply.push(traverseQueryFilters(throwPassword, ctx));\n    }\n\n    if (include.includes('private')) {\n      functionsToApply.push(traverseQueryFilters(throwPrivate, ctx));\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return filters;\n    }\n\n    return pipeAsync(...functionsToApply)(filters);\n  }\n);\n\nexport const defaultValidateFilters = asyncCurry(async (ctx: Context, filters: unknown) => {\n  return validateFilters(ctx, filters, FILTER_TRAVERSALS);\n});\n\nexport const SORT_TRAVERSALS = [\n  'nonAttributesOperators',\n  'dynamicZones',\n  'morphRelations',\n  'passwords',\n  'private',\n  'nonScalarEmptyKeys',\n];\n\nexport const validateSort = asyncCurry(\n  async (ctx: Context, sort: unknown, include: (typeof SORT_TRAVERSALS)[number][]) => {\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidateSort');\n    }\n\n    // Build the list of functions conditionally based on the include array\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // Validate non attribute keys\n    if (include.includes('nonAttributesOperators')) {\n      functionsToApply.push(\n        traverseQuerySort(({ key, attribute, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not removing it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          if (!attribute) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    // Validate dynamic zones from sort\n    if (include.includes('dynamicZones')) {\n      functionsToApply.push(traverseQuerySort(throwDynamicZones, ctx));\n    }\n\n    // Validate morphTo relations from sort\n    if (include.includes('morphRelations')) {\n      functionsToApply.push(traverseQuerySort(throwMorphToRelations, ctx));\n    }\n\n    // Validate passwords from sort\n    if (include.includes('passwords')) {\n      functionsToApply.push(traverseQuerySort(throwPassword, ctx));\n    }\n\n    // Validate private from sort\n    if (include.includes('private')) {\n      functionsToApply.push(traverseQuerySort(throwPrivate, ctx));\n    }\n\n    // Validate non-scalar empty keys\n    if (include.includes('nonScalarEmptyKeys')) {\n      functionsToApply.push(\n        traverseQuerySort(({ key, attribute, value, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not removing it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          if (!isScalarAttribute(attribute) && isEmpty(value)) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return sort;\n    }\n\n    return pipeAsync(...functionsToApply)(sort);\n  }\n);\n\nexport const defaultValidateSort = asyncCurry(async (ctx: Context, sort: unknown) => {\n  return validateSort(ctx, sort, SORT_TRAVERSALS);\n});\n\nexport const FIELDS_TRAVERSALS = ['scalarAttributes', 'privateFields', 'passwordFields'];\n\nexport const validateFields = asyncCurry(\n  async (ctx: Context, fields: unknown, include: (typeof FIELDS_TRAVERSALS)[number][]) => {\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidateFields');\n    }\n    // Build the list of functions conditionally based on the include array\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // Only allow scalar attributes\n    if (include.includes('scalarAttributes')) {\n      functionsToApply.push(\n        traverseQueryFields(({ key, attribute, path }) => {\n          // ID is not an attribute per se, so we need to make\n          // an extra check to ensure we're not throwing because of it\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\n            return;\n          }\n\n          if (isNil(attribute) || !isScalarAttribute(attribute)) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        }, ctx)\n      );\n    }\n\n    // Private fields\n    if (include.includes('privateFields')) {\n      functionsToApply.push(traverseQueryFields(throwPrivate, ctx));\n    }\n\n    // Password fields\n    if (include.includes('passwordFields')) {\n      functionsToApply.push(traverseQueryFields(throwPassword, ctx));\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return fields;\n    }\n\n    return pipeAsync(...functionsToApply)(fields);\n  }\n);\n\nexport const defaultValidateFields = asyncCurry(async (ctx: Context, fields: unknown) => {\n  return validateFields(ctx, fields, FIELDS_TRAVERSALS);\n});\n\nexport const POPULATE_TRAVERSALS = ['nonAttributesOperators', 'private'];\n\nexport const validatePopulate = asyncCurry(\n  async (\n    ctx: PopulateContext,\n    populate: unknown,\n    includes: {\n      fields?: (typeof FIELDS_TRAVERSALS)[number][];\n      sort?: (typeof SORT_TRAVERSALS)[number][];\n      filters?: (typeof FILTER_TRAVERSALS)[number][];\n      populate?: (typeof POPULATE_TRAVERSALS)[number][];\n    }\n  ) => {\n    if (!ctx.schema) {\n      throw new Error('Missing schema in defaultValidatePopulate');\n    }\n    // Build the list of functions conditionally based on the include array\n    const functionsToApply: Array<AnyFunc> = [];\n\n    // Always include the main traversal function\n    functionsToApply.push(\n      traverseQueryPopulate(\n        async ({ key, path, value, schema, attribute, getModel, parent }, { set }) => {\n          /**\n           * NOTE: The parent check is done to support \"filters\" (and the rest of keys) as valid attribute names.\n           *\n           * The parent will not be an attribute when its a \"populate\" / \"filters\" / \"sort\" ... key.\n           * Only in those scenarios the node will be an attribute.\n           */\n          if (!parent?.attribute && attribute) {\n            const isPopulatableAttribute = [\n              'relation',\n              'dynamiczone',\n              'component',\n              'media',\n            ].includes(attribute.type);\n\n            // Throw on non-populate attributes\n            if (!isPopulatableAttribute) {\n              throwInvalidKey({ key, path: path.raw });\n            }\n\n            // Valid populatable attribute, so return\n            return;\n          }\n\n          // If we're looking at a populate fragment, ensure its target is valid\n          if (key === 'on') {\n            // Populate fragment should always be an object\n            if (!isObject(value)) {\n              return throwInvalidKey({ key, path: path.raw });\n            }\n\n            const targets = Object.keys(value);\n\n            for (const target of targets) {\n              const model = getModel(target);\n\n              // If a target is invalid (no matching model), then raise an error\n              if (!model) {\n                throwInvalidKey({ key: target, path: `${path.raw}.${target}` });\n              }\n            }\n\n            // If the fragment's target is fine, then let it pass\n            return;\n          }\n\n          // Ignore plain wildcards\n          if (key === '' && value === '*') {\n            return;\n          }\n\n          // Ensure count is a boolean\n          if (key === 'count') {\n            try {\n              parseType({ type: 'boolean', value });\n              return;\n            } catch {\n              throwInvalidKey({ key, path: path.attribute });\n            }\n          }\n\n          // Allowed boolean-like keywords should be ignored\n          try {\n            parseType({ type: 'boolean', value: key });\n            // Key is an allowed boolean-like keyword, skipping validation...\n            return;\n          } catch {\n            // Continue, because it's not a boolean-like\n          }\n\n          // Handle nested `sort` validation with custom or default traversals\n          if (key === 'sort') {\n            set(\n              key,\n              await validateSort(\n                {\n                  schema,\n                  getModel,\n                },\n                value, // pass the sort value\n                includes?.sort || SORT_TRAVERSALS\n              )\n            );\n            return;\n          }\n\n          // Handle nested `filters` validation with custom or default traversals\n          if (key === 'filters') {\n            set(\n              key,\n              await validateFilters(\n                {\n                  schema,\n                  getModel,\n                },\n                value, // pass the filters value\n                includes?.filters || FILTER_TRAVERSALS\n              )\n            );\n            return;\n          }\n\n          // Handle nested `fields` validation with custom or default traversals\n          if (key === 'fields') {\n            set(\n              key,\n              await validateFields(\n                {\n                  schema,\n                  getModel,\n                },\n                value, // pass the fields value\n                includes?.fields || FIELDS_TRAVERSALS\n              )\n            );\n            return;\n          }\n\n          // Handle recursive nested `populate` validation with the same include object\n          if (key === 'populate') {\n            set(\n              key,\n              await validatePopulate(\n                {\n                  schema,\n                  getModel,\n                  parent: { key, path, schema, attribute },\n                  path,\n                },\n                value, // pass the nested populate value\n                includes // pass down the same includes object\n              )\n            );\n            return;\n          }\n\n          // Throw an error if non-attribute operators are included in the populate array\n          if (includes?.populate?.includes('nonAttributesOperators')) {\n            throwInvalidKey({ key, path: path.attribute });\n          }\n        },\n        ctx\n      )\n    );\n\n    // Conditionally traverse for private fields only if 'private' is included\n    if (includes?.populate?.includes('private')) {\n      functionsToApply.push(traverseQueryPopulate(throwPrivate, ctx));\n    }\n\n    // Return directly if no validation functions are provided\n    if (functionsToApply.length === 0) {\n      return populate;\n    }\n\n    return pipeAsync(...functionsToApply)(populate);\n  }\n);\n\nexport const defaultValidatePopulate = asyncCurry(async (ctx: Context, populate: unknown) => {\n  if (!ctx.schema) {\n    throw new Error('Missing schema in defaultValidatePopulate');\n  }\n\n  // Call validatePopulate and include all validations by passing in full traversal arrays\n  return validatePopulate(ctx, populate, {\n    filters: FILTER_TRAVERSALS,\n    sort: SORT_TRAVERSALS,\n    fields: FIELDS_TRAVERSALS,\n    populate: POPULATE_TRAVERSALS,\n  });\n});\n","import { CurriedFunction1 } from 'lodash';\nimport { isArray, isObject } from 'lodash/fp';\n\nimport { getNonWritableAttributes, constants } from '../content-types';\nimport { pipe as pipeAsync } from '../async';\nimport { throwInvalidKey } from './utils';\n\nimport * as visitors from './visitors';\nimport * as validators from './validators';\nimport traverseEntity from '../traverse-entity';\n\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\n\nimport { Model, Data } from '../types';\nimport { ValidationError } from '../errors';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\n\nexport interface Options {\n  auth?: unknown;\n}\n\nexport interface Validator {\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\n}\nexport interface ValidateFunc {\n  (data: unknown, schema: Model, options?: Options): Promise<void>;\n}\n\ninterface APIOptions {\n  validators?: Validators;\n  getModel: (model: string) => Model;\n}\n\nexport interface Validators {\n  input?: Validator[];\n}\n\nconst createAPIValidators = (opts: APIOptions) => {\n  const { getModel } = opts || {};\n\n  const validateInput: ValidateFunc = async (data: unknown, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateInput');\n    }\n\n    if (isArray(data)) {\n      await Promise.all(data.map((entry) => validateInput(entry, schema, { auth })));\n      return;\n    }\n\n    const nonWritableAttributes = getNonWritableAttributes(schema);\n\n    const transforms = [\n      (data: unknown) => {\n        if (isObject(data)) {\n          if (ID_ATTRIBUTE in data) {\n            throwInvalidKey({ key: ID_ATTRIBUTE });\n          }\n\n          if (DOC_ID_ATTRIBUTE in data) {\n            throwInvalidKey({ key: DOC_ID_ATTRIBUTE });\n          }\n        }\n        return data;\n      },\n      // non-writable attributes\n      traverseEntity(visitors.throwRestrictedFields(nonWritableAttributes), { schema, getModel }),\n      // unrecognized attributes\n      traverseEntity(visitors.throwUnrecognizedFields, { schema, getModel }),\n    ];\n\n    if (auth) {\n      // restricted relations\n      transforms.push(\n        traverseEntity(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    // Apply validators from registry if exists\n    opts?.validators?.input?.forEach((validator: Validator) => transforms.push(validator(schema)));\n\n    try {\n      await pipeAsync(...transforms)(data as Data);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'body';\n      }\n      throw e;\n    }\n  };\n\n  const validateQuery = async (\n    query: Record<string, unknown>,\n    schema: Model,\n    { auth }: Options = {}\n  ) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateQuery');\n    }\n    const { filters, sort, fields, populate } = query;\n\n    if (filters) {\n      await validateFilters(filters, schema, { auth });\n    }\n\n    if (sort) {\n      await validateSort(sort, schema, { auth });\n    }\n\n    if (fields) {\n      await validateFields(fields, schema);\n    }\n\n    // a wildcard is always valid; its conversion will be handled by the entity service and can be optimized with sanitizer\n    if (populate && populate !== '*') {\n      await validatePopulate(populate, schema);\n    }\n  };\n\n  const validateFilters: ValidateFunc = async (filters, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateFilters');\n    }\n    if (isArray(filters)) {\n      await Promise.all(filters.map((filter) => validateFilters(filter, schema, { auth })));\n      return;\n    }\n\n    const transforms = [validators.defaultValidateFilters({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryFilters(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    try {\n      await pipeAsync(...transforms)(filters);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'filters';\n      }\n      throw e;\n    }\n  };\n\n  const validateSort: ValidateFunc = async (sort, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateSort');\n    }\n    const transforms = [validators.defaultValidateSort({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQuerySort(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    try {\n      await pipeAsync(...transforms)(sort);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'sort';\n      }\n      throw e;\n    }\n  };\n\n  const validateFields: ValidateFunc = async (fields, schema: Model) => {\n    if (!schema) {\n      throw new Error('Missing schema in validateFields');\n    }\n    const transforms = [validators.defaultValidateFields({ schema, getModel })];\n\n    try {\n      await pipeAsync(...transforms)(fields);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'fields';\n      }\n      throw e;\n    }\n  };\n\n  const validatePopulate: ValidateFunc = async (populate, schema: Model, { auth } = {}) => {\n    if (!schema) {\n      throw new Error('Missing schema in sanitizePopulate');\n    }\n    const transforms = [validators.defaultValidatePopulate({ schema, getModel })];\n\n    if (auth) {\n      transforms.push(\n        traverseQueryPopulate(visitors.throwRestrictedRelations(auth), {\n          schema,\n          getModel,\n        })\n      );\n    }\n\n    try {\n      await pipeAsync(...transforms)(populate);\n    } catch (e) {\n      if (e instanceof ValidationError) {\n        e.details.source = 'query';\n        e.details.param = 'populate';\n      }\n      throw e;\n    }\n  };\n\n  return {\n    input: validateInput,\n    query: validateQuery,\n    filters: validateFilters,\n    sort: validateSort,\n    fields: validateFields,\n    populate: validatePopulate,\n  };\n};\n\nexport { createAPIValidators, validators, visitors };\n\nexport type APIValidators = ReturnType<typeof createAPIValidators>;\n","import { merge, pipe, omit, isNil } from 'lodash/fp';\nimport { PaginationError } from './errors';\n\ninterface PaginationArgs {\n  page: number;\n  pageSize: number;\n  start: number;\n  limit: number;\n}\n\nexport interface Pagination {\n  start: number;\n  limit: number;\n}\n\nexport interface PagePatinationInformation {\n  page: number;\n  pageSize: number;\n  pageCount: number;\n  total: number;\n}\n\nexport interface OffsetPaginationInformation {\n  start: number;\n  limit: number;\n  total: number;\n}\n\nconst STRAPI_DEFAULTS = {\n  offset: {\n    start: 0,\n    limit: 10,\n  },\n  page: {\n    page: 1,\n    pageSize: 10,\n  },\n};\n\nconst paginationAttributes = ['start', 'limit', 'page', 'pageSize'];\n\nconst withMaxLimit = (limit: number, maxLimit = -1) => {\n  if (maxLimit === -1 || limit < maxLimit) {\n    return limit;\n  }\n\n  return maxLimit;\n};\n\n// Ensure minimum page & pageSize values (page >= 1, pageSize >= 0, start >= 0, limit >= 0)\nconst ensureMinValues = ({ start, limit }: Pagination) => ({\n  start: Math.max(start, 0),\n  limit: limit === -1 ? limit : Math.max(limit, 1),\n});\n\nconst ensureMaxValues =\n  (maxLimit = -1) =>\n  ({ start, limit }: { start: number; limit: number }) => ({\n    start,\n    limit: withMaxLimit(limit, maxLimit),\n  });\n\n// Apply maxLimit as the limit when limit is -1\nconst withNoLimit = (pagination: Pagination, maxLimit = -1) => ({\n  ...pagination,\n  limit: pagination.limit === -1 ? maxLimit : pagination.limit,\n});\n\nconst withDefaultPagination = <T extends Partial<PaginationArgs>>(\n  args: T,\n  { defaults = {}, maxLimit = -1 } = {}\n) => {\n  const defaultValues = merge(STRAPI_DEFAULTS, defaults);\n\n  const usePagePagination = !isNil(args.page) || !isNil(args.pageSize);\n  const useOffsetPagination = !isNil(args.start) || !isNil(args.limit);\n\n  const ensureValidValues = pipe(ensureMinValues, ensureMaxValues(maxLimit));\n\n  // If there is no pagination attribute, don't modify the payload\n  if (!usePagePagination && !useOffsetPagination) {\n    return merge(args, ensureValidValues(defaultValues.offset));\n  }\n\n  // If there is page & offset pagination attributes, throw an error\n  if (usePagePagination && useOffsetPagination) {\n    throw new PaginationError('Cannot use both page & offset pagination in the same query');\n  }\n\n  const pagination: Pagination = {\n    start: 0,\n    limit: 0,\n  };\n\n  // Start / Limit\n  if (useOffsetPagination) {\n    const { start, limit } = merge(defaultValues.offset, args);\n\n    Object.assign(pagination, { start, limit });\n  }\n\n  // Page / PageSize\n  if (usePagePagination) {\n    const { page, pageSize } = merge(defaultValues.page, {\n      ...args,\n      pageSize: Math.max(1, args.pageSize ?? 0),\n    });\n\n    Object.assign(pagination, {\n      start: (page - 1) * pageSize,\n      limit: pageSize,\n    });\n  }\n\n  // Handle -1 limit\n  Object.assign(pagination, withNoLimit(pagination, maxLimit));\n\n  const replacePaginationAttributes = pipe(\n    // Remove pagination attributes\n    omit(paginationAttributes),\n    // Merge the object with the new pagination + ensure minimum & maximum values\n    merge(ensureValidValues(pagination))\n  );\n\n  return replacePaginationAttributes(args);\n};\n\n/**\n * Transform pagination information into a paginated response:\n * {\n *    page: number,\n *    pageSize: number,\n *    pageCount: number,\n *    total: number\n * }\n */\nconst transformPagedPaginationInfo = (\n  paginationInfo: Partial<PaginationArgs>,\n  total: number\n): PagePatinationInformation => {\n  if (!isNil(paginationInfo.page)) {\n    const page = paginationInfo.page;\n    const pageSize = paginationInfo.pageSize ?? total;\n\n    return {\n      page,\n      pageSize,\n      pageCount: pageSize > 0 ? Math.ceil(total / pageSize) : 0,\n      total,\n    };\n  }\n\n  if (!isNil(paginationInfo.start)) {\n    const start = paginationInfo.start;\n    const limit = paginationInfo.limit ?? total;\n\n    // Start limit to page page size\n    return {\n      page: Math.floor(start / limit) + 1,\n      pageSize: limit,\n      pageCount: limit > 0 ? Math.ceil(total / limit) : 0,\n      total,\n    };\n  }\n\n  // Default pagination\n  return {\n    ...paginationInfo,\n    page: 1,\n    pageSize: 10,\n    pageCount: 1,\n    total,\n  };\n};\n\n/**\n * Transform pagination information into a offset response:\n * {\n *    start: number,\n *    limit: number,\n *    total: number\n * }\n */\nconst transformOffsetPaginationInfo = (\n  paginationInfo: Partial<PaginationArgs>,\n  total: number\n): OffsetPaginationInformation => {\n  if (!isNil(paginationInfo.page)) {\n    const limit = paginationInfo.pageSize ?? total;\n    const start = (paginationInfo.page - 1) * limit;\n\n    return { start, limit, total };\n  }\n\n  if (!isNil(paginationInfo.start)) {\n    const start = paginationInfo.start;\n    const limit = paginationInfo.limit ?? total;\n\n    // Start limit to page page size\n    return { start, limit, total };\n  }\n\n  // Default pagination\n  return {\n    ...paginationInfo,\n    start: 0,\n    limit: 10,\n    total,\n  };\n};\n\nexport { withDefaultPagination, transformPagedPaginationInfo, transformOffsetPaginationInfo };\n","import execa from 'execa';\nimport preferredPM from 'preferred-pm';\n\nimport type { Options as ProcessOptions } from 'execa';\n\nconst SUPPORTED_PACKAGE_MANAGERS = ['npm', 'yarn'];\nconst DEFAULT_PACKAGE_MANAGER = 'npm' as const;\n\ntype SupportedPackageManagerName = 'npm' | 'yarn';\n\nexport const getPreferred = async (pkgPath: string): Promise<SupportedPackageManagerName> => {\n  const pm = await preferredPM(pkgPath);\n\n  const hasPackageManager = pm !== undefined;\n  if (!hasPackageManager) {\n    throw new Error(`Couldn't find a package manager in your project.`);\n  }\n\n  const isPackageManagerSupported = SUPPORTED_PACKAGE_MANAGERS.includes(pm.name);\n  if (!isPackageManagerSupported) {\n    process.emitWarning(\n      `We detected your package manager (${pm.name} v${pm.version}), but it's not officially supported by Strapi yet. Defaulting to npm instead.`\n    );\n\n    return DEFAULT_PACKAGE_MANAGER;\n  }\n\n  return pm.name as SupportedPackageManagerName;\n};\n\nexport const installDependencies = (\n  path: string,\n  packageManager: SupportedPackageManagerName,\n  options: ProcessOptions<string> = {}\n) => {\n  return execa(packageManager, ['install'], { ...options, cwd: path, stdin: 'ignore' });\n};\n","/**\n * Create a strict interpolation RegExp based on the given variables' name\n */\nconst createStrictInterpolationRegExp = (allowedVariableNames: string[], flags: string) => {\n  const oneOfVariables = allowedVariableNames.join('|');\n\n  // 1. We need to match the delimiters: <%= ... %>\n  // 2. We accept any number of whitespaces characters before and/or after the variable name: \\s* ... \\s*\n  // 3. We only accept values from the variable list as interpolation variables' name: : (${oneOfVariables})\n  return new RegExp(`<%=\\\\s*(${oneOfVariables})\\\\s*%>`, flags);\n};\n\n/**\n * Create a loose interpolation RegExp to match as many groups as possible\n */\nconst createLooseInterpolationRegExp = (flags: string) => new RegExp(/<%=([\\s\\S]+?)%>/, flags);\n\nexport { createStrictInterpolationRegExp, createLooseInterpolationRegExp };\n","/**\n * Utils file containing file treatment utils\n */\nimport { Writable, WritableOptions } from 'node:stream';\n\nconst kbytesToBytes = (kbytes: number) => kbytes * 1000;\nconst bytesToKbytes = (bytes: number) => Math.round((bytes / 1000) * 100) / 100;\nconst bytesToHumanReadable = (bytes: number) => {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  if (bytes === 0) return '0 Bytes';\n  const i = parseInt(`${Math.floor(Math.log(bytes) / Math.log(1000))}`, 10);\n  return `${Math.round(bytes / 1000 ** i)} ${sizes[i]}`;\n};\n\nconst streamToBuffer = (stream: NodeJS.ReadableStream): Promise<Buffer> =>\n  new Promise((resolve, reject) => {\n    const chunks: Uint8Array[] = [];\n    stream.on('data', (chunk) => {\n      chunks.push(chunk);\n    });\n    stream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on('error', reject);\n  });\n\nconst getStreamSize = (stream: NodeJS.ReadableStream) =>\n  new Promise((resolve, reject) => {\n    let size = 0;\n    stream.on('data', (chunk) => {\n      size += Buffer.byteLength(chunk);\n    });\n    stream.on('close', () => resolve(size));\n    stream.on('error', reject);\n    stream.resume();\n  });\n\n/**\n * Create a writeable Node.js stream that discards received data.\n * Useful for testing, draining a stream of data, etc.\n */\nfunction writableDiscardStream(options?: WritableOptions) {\n  return new Writable({\n    ...options,\n    write(chunk, encding, callback) {\n      setImmediate(callback);\n    },\n  });\n}\n\nexport {\n  streamToBuffer,\n  bytesToHumanReadable,\n  bytesToKbytes,\n  kbytesToBytes,\n  getStreamSize,\n  writableDiscardStream,\n};\n","import { eq } from 'lodash/fp';\n\ninterface Options {\n  name: string;\n  validator?(config: unknown): void;\n  handler(...args: any[]): any;\n}\n\nconst createPolicy = (options: Options) => {\n  const { name = 'unnamed', validator, handler } = options;\n\n  const wrappedValidator = (config: unknown) => {\n    if (validator) {\n      try {\n        validator(config);\n      } catch (e) {\n        throw new Error(`Invalid config passed to \"${name}\" policy.`);\n      }\n    }\n  };\n\n  return {\n    name,\n    validator: wrappedValidator,\n    handler,\n  };\n};\n\nconst createPolicyContext = (type: string, ctx: object) => {\n  return Object.assign(\n    {\n      is: eq(type),\n      get type() {\n        return type;\n      },\n    },\n    ctx\n  );\n};\n\nexport { createPolicy, createPolicyContext };\n","import _, { kebabCase } from 'lodash';\nimport { trimChars, trimCharsEnd, trimCharsStart } from 'lodash/fp';\nimport slugify from '@sindresorhus/slugify';\n\nconst nameToSlug = (name: string, options: slugify.Options = { separator: '-' }) =>\n  slugify(name, options);\n\nconst nameToCollectionName = (name: string) => slugify(name, { separator: '_' });\n\nconst toRegressedEnumValue = (value: string) =>\n  slugify(value, {\n    decamelize: false,\n    lowercase: false,\n    separator: '_',\n  });\n\nconst getCommonPath = (...paths: string[]) => {\n  const [segments, ...otherSegments] = paths.map((it) => _.split(it, '/'));\n  return _.join(\n    _.takeWhile(segments, (str, index) => otherSegments.every((it) => it[index] === str)),\n    '/'\n  );\n};\n\nconst isEqual = (a: unknown, b: unknown) => String(a) === String(b);\nconst isCamelCase = (value: string) => /^[a-z][a-zA-Z0-9]+$/.test(value);\nconst isKebabCase = (value: string) => /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/.test(value);\nconst startsWithANumber = (value: string) => /^[0-9]/.test(value);\n\nconst joinBy = (joint: string, ...args: string[]) => {\n  const trim = trimChars(joint);\n  const trimEnd = trimCharsEnd(joint);\n  const trimStart = trimCharsStart(joint);\n\n  return args.reduce((url, path, index) => {\n    if (args.length === 1) return path;\n    if (index === 0) return trimEnd(path);\n    if (index === args.length - 1) return url + joint + trimStart(path);\n    return url + joint + trim(path);\n  }, '');\n};\n\nconst toKebabCase = (value: string) => kebabCase(value);\n\nexport {\n  nameToSlug,\n  nameToCollectionName,\n  getCommonPath,\n  isEqual,\n  isCamelCase,\n  isKebabCase,\n  toKebabCase,\n  toRegressedEnumValue,\n  startsWithANumber,\n  joinBy,\n};\n","const castIncludes = (arr: unknown[], val: unknown, cast: (val: unknown) => unknown): boolean =>\n  arr.map((val) => cast(val)).includes(cast(val));\n\nconst includesString = (arr: unknown[], val: unknown) => castIncludes(arr, val, String);\n\nexport { includesString };\n","import _ from 'lodash';\n\nconst keysDeep = (obj: object, path: string[] = []): string[] =>\n  !_.isObject(obj)\n    ? [path.join('.')]\n    : _.reduce(\n        obj,\n        (acc, next, key) => _.concat(acc, keysDeep(next, [...path, key])),\n        [] as string[]\n      );\n\nexport { keysDeep };\n","// Using timestamp (milliseconds) to be sure it is unique\n// + converting timestamp to base 36 for better readibility\nconst timestampCode = (date?: Date) => {\n  const referDate = date ?? new Date();\n\n  return referDate.getTime().toString(36);\n};\n\nexport { timestampCode };\n","// Code copied from the yup library (https://github.com/jquense/yup)\n// https://github.com/jquense/yup/blob/2778b88bdacd5260d593c6468793da2e77daf21f/src/util/printValue.ts\n\nconst { toString } = Object.prototype;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\n\nfunction printNumber(val: number) {\n  // eslint-disable-next-line eqeqeq\n  if (val != +val) return 'NaN';\n  const isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? '-0' : `${val}`;\n}\n\nfunction printSimpleValue(val: unknown, quoteStrings = false) {\n  if (val == null || val === true || val === false) return `${val}`;\n\n  if (typeof val === 'number') return printNumber(val);\n  if (typeof val === 'string') return quoteStrings ? `\"${val}\"` : val;\n  if (typeof val === 'function') return `[Function ${val.name || 'anonymous'}]`;\n  if (typeof val === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n\n  const tag = toString.call(val).slice(8, -1);\n\n  if (tag === 'Date') {\n    const v = val as Date;\n    return Number.isNaN(v.getTime()) ? `${v}` : v.toISOString();\n  }\n  if (tag === 'Error' || val instanceof Error) return `[${errorToString.call(val)}]`;\n  if (tag === 'RegExp') return regExpToString.call(val);\n\n  return null;\n}\n\nfunction printValue(value: unknown, quoteStrings: boolean) {\n  const result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n\n  return JSON.stringify(\n    value,\n    function replacer(key, value) {\n      const result = printSimpleValue(this[key], quoteStrings);\n      if (result !== null) return result;\n      return value;\n    },\n    2\n  );\n}\n\nexport { printValue };\n","/* eslint-disable no-template-curly-in-string */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport * as yup from 'yup';\nimport _ from 'lodash';\nimport { isNumber, isInteger, get } from 'lodash/fp';\nimport { strings } from './primitives';\nimport { printValue } from './print-value';\n\nexport * from 'yup';\n\nexport const strapiID = (): InstanceType<typeof StrapiIDSchema> => new StrapiIDSchema();\n\nconst isNotNilTest = (value: unknown) => !_.isNil(value);\n\nconst isNotNullTest = (value: unknown) => !_.isNull(value);\n\nyup.addMethod(yup.mixed, 'notNil', function isNotNill(msg = '${path} must be defined.') {\n  return this.test('defined', msg, isNotNilTest);\n});\n\nyup.addMethod(yup.mixed, 'notNull', function isNotNull(msg = '${path} cannot be null.') {\n  return this.test('defined', msg, isNotNullTest);\n});\n\nyup.addMethod(yup.mixed, 'isFunction', function isFunction(message = '${path} is not a function') {\n  return this.test(\n    'is a function',\n    message,\n    (value) => _.isUndefined(value) || _.isFunction(value)\n  );\n});\n\nyup.addMethod(\n  yup.string,\n  'isCamelCase',\n  function isCamelCase(message = '${path} is not in camel case (anExampleOfCamelCase)') {\n    return this.test('is in camelCase', message, (value) =>\n      value ? strings.isCamelCase(value) : true\n    );\n  }\n);\n\nyup.addMethod(\n  yup.string,\n  'isKebabCase',\n  function isKebabCase(message = '${path} is not in kebab case (an-example-of-kebab-case)') {\n    return this.test('is in kebab-case', message, (value) =>\n      value ? strings.isKebabCase(value) : true\n    );\n  }\n);\n\nyup.addMethod(\n  yup.object,\n  'onlyContainsFunctions',\n  function onlyContainsFunctions(message = '${path} contains values that are not functions') {\n    return this.test(\n      'only contains functions',\n      message,\n      (value) => _.isUndefined(value) || (value && Object.values(value).every(_.isFunction))\n    );\n  }\n);\n\nyup.addMethod(\n  yup.array,\n  'uniqueProperty',\n  function uniqueProperty(propertyName: string, message: string) {\n    return this.test('unique', message, function unique(list) {\n      const errors: yup.ValidationError[] = [];\n\n      list?.forEach((element, index) => {\n        const sameElements = list.filter(\n          (e) => get(propertyName, e) === get(propertyName, element)\n        );\n        if (sameElements.length > 1) {\n          errors.push(\n            this.createError({\n              path: `${this.path}[${index}].${propertyName}`,\n              message,\n            })\n          );\n        }\n      });\n\n      if (errors.length) {\n        throw new yup.ValidationError(errors);\n      }\n      return true;\n    });\n  }\n);\n\nexport class StrapiIDSchema extends yup.MixedSchema {\n  constructor() {\n    super({ type: 'strapiID' });\n  }\n\n  _typeCheck(value: unknown): value is string | number {\n    return typeof value === 'string' || (isNumber(value) && isInteger(value) && value >= 0);\n  }\n}\n\ndeclare module 'yup' {\n  // const strapiID: () => InstanceType<typeof StrapiIDSchema>;\n\n  export interface BaseSchema {\n    isFunction(message?: string): this;\n    notNil(message?: string): this;\n    notNull(message?: string): this;\n  }\n\n  export interface StringSchema {\n    isCamelCase(message?: string): this;\n    isKebabCase(message?: string): this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  export interface ObjectSchema<TShape> {\n    onlyContainsFunctions(message?: string): this;\n  }\n}\n\ninterface NoTypeOptions {\n  path: string;\n  type: string;\n  value: unknown;\n  originalValue: unknown;\n}\n\n// Temporary fix of this issue : https://github.com/jquense/yup/issues/616\nyup.setLocale({\n  mixed: {\n    notType(options: NoTypeOptions) {\n      const { path, type, value, originalValue } = options;\n      const isCast = originalValue != null && originalValue !== value;\n      const msg =\n        `${path} must be a \\`${type}\\` type, ` +\n        `but the final value was: \\`${printValue(value, true)}\\`${\n          isCast ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : '.'\n        }`;\n\n      /* Remove comment that is not supposed to be seen by the enduser\n      if (value === null) {\n        msg += `\\n If \"null\" is intended as an empty value be sure to mark the schema as \\`.nullable()\\``;\n      }\n      */\n      return msg;\n    },\n  },\n});\n","import { z } from 'zod';\n\nimport { ValidationError } from './errors';\n\nexport const validateZod =\n  <T extends z.ZodTypeAny>(schema: T) =>\n  (data: unknown): z.TypeOf<T> => {\n    try {\n      return schema.parse(data);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const { message, errors } = formatZodErrors(error);\n        throw new ValidationError(message, { errors });\n      }\n\n      throw error;\n    }\n  };\n\nconst formatZodErrors = (zodError: z.ZodError) => ({\n  errors: zodError.errors.map((error) => {\n    return {\n      path: error.path,\n      message: error.message,\n      name: 'ValidationError',\n    };\n  }),\n  message: 'Validation error',\n});\n"],"names":["dates","_","ID_ATTRIBUTE","DOC_ID_ATTRIBUTE","PUBLISHED_AT_ATTRIBUTE","CREATED_BY_ATTRIBUTE","UPDATED_BY_ATTRIBUTE","constants","has","union","getOr","contentTypes.constants","assoc","assign","remove","eq","cloneDeep","visitor","path","schema","isObject","isNil","clone","isArray","i","curry","machineIdSync","randomUUID","toPath","isEmpty","errors","defaults","yup","isString","isStringArray","toNumber","isInteger","populate","value","key","acc","sort","filters","fields","get","pMap","isBoolean","ACTIONS_TO_VERIFY","contentTypeUtils.constants","hasAccessToSomeScopes","contentTypeUtils.isMorphToRelationalAttribute","getContainedPaths","index","parser","utils","pick","isObj","omit","trim","pipe","split","map","flatten","first","identity","constant","join","newValue","traverseEntity","removePassword","removePrivate","pipeAsync","removeDynamicZones","removeMorphToRelations","expandWildcardPopulate","visitors.removeRestrictedFields","visitors.removeRestrictedRelations","data","sanitizers.defaultSanitizeOutput","sanitizers.defaultSanitizeFilters","sanitizers.defaultSanitizeSort","sanitizers.defaultSanitizeFields","sanitizers.defaultSanitizePopulate","throwDynamicZones","throwMorphToRelations","throwPassword","throwPrivate","visitors.throwRestrictedFields","visitors.throwUnrecognizedFields","visitors.throwRestrictedRelations","validateFilters","validateSort","validateFields","validatePopulate","validators.defaultValidateFilters","validators.defaultValidateSort","validators.defaultValidateFields","validators.defaultValidatePopulate","pagination","merge","preferredPM","packageManager","execa","Writable","slugify","trimChars","trimCharsEnd","trimCharsStart","kebabCase","val","result","isCamelCase","strings.isCamelCase","isKebabCase","strings.isKebabCase","isNumber","z"],"mappings":"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"}