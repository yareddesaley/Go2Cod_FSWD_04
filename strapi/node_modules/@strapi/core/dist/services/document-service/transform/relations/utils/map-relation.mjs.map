{"version":3,"file":"map-relation.mjs","sources":["../../../../../../src/services/document-service/transform/relations/utils/map-relation.ts"],"sourcesContent":["/* eslint-disable node/no-callback-literal */\nimport { isObject, curry, isNil } from 'lodash/fp';\n\nimport type { UID } from '@strapi/types';\nimport { traverseEntity, async } from '@strapi/utils';\n\nimport { Relation } from './types';\n\nconst isNumeric = (value: any): value is number => {\n  if (Array.isArray(value)) return false; // Handle [1, 'docId'] case\n  const parsed = parseInt(value, 10);\n  return !Number.isNaN(parsed);\n};\n\nconst toArray = (value: any) => {\n  // Keep value as it is if it's a nullish value\n  if (isNil(value)) return value;\n  if (Array.isArray(value)) return value;\n\n  return [value];\n};\n\n/**\n * There are multiple ways to create Strapi relations.\n * This is a utility to traverse and transform relation data\n *\n *\n * For consistency and ease of use, the response will always be an object with the following shape:\n * { set: [{...}], connect: [{...}], disconnect: [{...}] }\n *\n * @example\n * transformRelationData({\n *  onLongHand: (relation) => {\n *    // Change the id of the relation\n *    return { id: 'other' };\n *  },\n * }, relation)\n */\nconst mapRelation = async (\n  callback: (relation: any) => any,\n  rel: Relation,\n  isRecursive = false\n): Promise<Relation> => {\n  let relation: Relation = rel;\n\n  const wrapInSet = (value: any) => {\n    // Ignore wrapping if it's a recursive call\n    if (isRecursive) {\n      return value;\n    }\n    return { set: toArray(value) };\n  };\n\n  // undefined | null\n  if (isNil(relation)) {\n    return callback(relation);\n  }\n\n  // LongHand[] | ShortHand[]\n  if (Array.isArray(relation)) {\n    return async\n      .map(relation, (r: Relation) => mapRelation(callback, r, true))\n      .then((result: any) => result.flat().filter(Boolean))\n      .then(wrapInSet);\n  }\n\n  // LongHand\n  if (isObject(relation)) {\n    // { id: 1 } || { documentId: 1 }\n    if ('id' in relation || 'documentId' in relation) {\n      const result = await callback(relation);\n      return wrapInSet(result);\n    }\n\n    // If not connecting anything, return default visitor\n    if (!relation.set && !relation.disconnect && !relation.connect) {\n      return callback(relation);\n    }\n\n    // { set }\n    if (relation.set) {\n      const set: any = await mapRelation(callback, relation.set, true);\n      relation = { ...relation, set: toArray(set) };\n    }\n\n    // { disconnect}\n    if (relation.disconnect) {\n      const disconnect: any = await mapRelation(callback, relation.disconnect, true);\n      relation = { ...relation, disconnect: toArray(disconnect) };\n    }\n\n    // { connect }\n    if (relation.connect) {\n      // Transform the relation to connect\n      const connect: any = await mapRelation(callback, relation.connect, true);\n      relation = { ...relation, connect: toArray(connect) };\n    }\n\n    return relation;\n  }\n\n  // ShortHand\n  if (isNumeric(relation)) {\n    const result = await callback({ id: relation });\n    return wrapInSet(result);\n  }\n\n  if (typeof relation === 'string') {\n    const result = await callback({ documentId: relation });\n    return wrapInSet(result);\n  }\n\n  // Anything else\n  return callback(relation);\n};\n\ntype TraverseEntity = Parameters<typeof traverseEntity>;\n\n/**\n * Utility function, same as `traverseEntity` but only for relations.\n */\nconst traverseEntityRelations = async (\n  visitor: TraverseEntity[0],\n  options: TraverseEntity[1],\n  data: TraverseEntity[2]\n) => {\n  return traverseEntity(\n    async (options, utils) => {\n      const { attribute } = options;\n\n      if (!attribute) {\n        return;\n      }\n\n      if (attribute.type !== 'relation') {\n        return;\n      }\n\n      // TODO: Handle join columns\n      if (attribute.useJoinTable === false) {\n        return;\n      }\n\n      // TODO: Handle morph relations (they have multiple targets)\n      const target = attribute.target as UID.Schema | undefined;\n      if (!target) {\n        return;\n      }\n\n      return visitor(options, utils);\n    },\n    options,\n    data\n  );\n};\n\nconst mapRelationCurried = curry(mapRelation);\nconst traverseEntityRelationsCurried = curry(traverseEntityRelations);\n\nexport {\n  mapRelationCurried as mapRelation,\n  traverseEntityRelationsCurried as traverseEntityRelations,\n};\n"],"names":["options"],"mappings":";;AAQA,MAAM,YAAY,CAAC,UAAgC;AAC7C,MAAA,MAAM,QAAQ,KAAK;AAAU,WAAA;AAC3B,QAAA,SAAS,SAAS,OAAO,EAAE;AAC1B,SAAA,CAAC,OAAO,MAAM,MAAM;AAC7B;AAEA,MAAM,UAAU,CAAC,UAAe;AAE9B,MAAI,MAAM,KAAK;AAAU,WAAA;AACrB,MAAA,MAAM,QAAQ,KAAK;AAAU,WAAA;AAEjC,SAAO,CAAC,KAAK;AACf;AAkBA,MAAM,cAAc,OAClB,UACA,KACA,cAAc,UACQ;AACtB,MAAI,WAAqB;AAEnB,QAAA,YAAY,CAAC,UAAe;AAEhC,QAAI,aAAa;AACR,aAAA;AAAA,IACT;AACA,WAAO,EAAE,KAAK,QAAQ,KAAK,EAAE;AAAA,EAAA;AAI3B,MAAA,MAAM,QAAQ,GAAG;AACnB,WAAO,SAAS,QAAQ;AAAA,EAC1B;AAGI,MAAA,MAAM,QAAQ,QAAQ,GAAG;AACpB,WAAA,MACJ,IAAI,UAAU,CAAC,MAAgB,YAAY,UAAU,GAAG,IAAI,CAAC,EAC7D,KAAK,CAAC,WAAgB,OAAO,OAAO,OAAO,OAAO,CAAC,EACnD,KAAK,SAAS;AAAA,EACnB;AAGI,MAAA,SAAS,QAAQ,GAAG;AAElB,QAAA,QAAQ,YAAY,gBAAgB,UAAU;AAC1C,YAAA,SAAS,MAAM,SAAS,QAAQ;AACtC,aAAO,UAAU,MAAM;AAAA,IACzB;AAGI,QAAA,CAAC,SAAS,OAAO,CAAC,SAAS,cAAc,CAAC,SAAS,SAAS;AAC9D,aAAO,SAAS,QAAQ;AAAA,IAC1B;AAGA,QAAI,SAAS,KAAK;AAChB,YAAM,MAAW,MAAM,YAAY,UAAU,SAAS,KAAK,IAAI;AAC/D,iBAAW,EAAE,GAAG,UAAU,KAAK,QAAQ,GAAG;IAC5C;AAGA,QAAI,SAAS,YAAY;AACvB,YAAM,aAAkB,MAAM,YAAY,UAAU,SAAS,YAAY,IAAI;AAC7E,iBAAW,EAAE,GAAG,UAAU,YAAY,QAAQ,UAAU;IAC1D;AAGA,QAAI,SAAS,SAAS;AAEpB,YAAM,UAAe,MAAM,YAAY,UAAU,SAAS,SAAS,IAAI;AACvE,iBAAW,EAAE,GAAG,UAAU,SAAS,QAAQ,OAAO;IACpD;AAEO,WAAA;AAAA,EACT;AAGI,MAAA,UAAU,QAAQ,GAAG;AACvB,UAAM,SAAS,MAAM,SAAS,EAAE,IAAI,SAAU,CAAA;AAC9C,WAAO,UAAU,MAAM;AAAA,EACzB;AAEI,MAAA,OAAO,aAAa,UAAU;AAChC,UAAM,SAAS,MAAM,SAAS,EAAE,YAAY,SAAU,CAAA;AACtD,WAAO,UAAU,MAAM;AAAA,EACzB;AAGA,SAAO,SAAS,QAAQ;AAC1B;AAOA,MAAM,0BAA0B,OAC9B,SACA,SACA,SACG;AACI,SAAA;AAAA,IACL,OAAOA,UAAS,UAAU;AAClB,YAAA,EAAE,UAAcA,IAAAA;AAEtB,UAAI,CAAC,WAAW;AACd;AAAA,MACF;AAEI,UAAA,UAAU,SAAS,YAAY;AACjC;AAAA,MACF;AAGI,UAAA,UAAU,iBAAiB,OAAO;AACpC;AAAA,MACF;AAGA,YAAM,SAAS,UAAU;AACzB,UAAI,CAAC,QAAQ;AACX;AAAA,MACF;AAEO,aAAA,QAAQA,UAAS,KAAK;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;AAEM,MAAA,qBAAqB,MAAM,WAAW;AACtC,MAAA,iCAAiC,MAAM,uBAAuB;"}